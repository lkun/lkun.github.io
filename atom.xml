<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lkun&#39;s</title>
  <subtitle>没有最好，只有更好；没有做不到，只有想不到；好好加油吧！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-09T04:30:01.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lkun&#39;s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker构建Mariadb数据库</title>
    <link href="http://yoursite.com/2018/09/09/docker/Docker%E6%9E%84%E5%BB%BAMariadb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2018/09/09/docker/Docker构建Mariadb数据库/</id>
    <published>2018-09-09T04:52:38.000Z</published>
    <updated>2018-09-09T04:30:01.180Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzc1MjE3MQ==&amp;mid=2247483667&amp;idx=1&amp;sn=70781512cae37ac5a7a527795574728d&amp;chksm=f9512c17ce26a5016061a893c4ebf67820de0c38eb4783d2bc237fd3eb966616d3e90a5b75f6&amp;token=242075731&amp;lang=zh_CN#rd" target="_blank" rel="external">Docker构建Mariadb数据库</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMzc1MjE3MQ==&amp;amp;mid=2247483667&amp;amp;idx=1&amp;amp;sn=70781512cae37ac5a7a527795574728d&amp;amp;chksm
    
    </summary>
    
      <category term="docker" scheme="http://yoursite.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>gradle项目打包到maven仓库</title>
    <link href="http://yoursite.com/2018/09/09/pack/gradle/gradle-to-maven/"/>
    <id>http://yoursite.com/2018/09/09/pack/gradle/gradle-to-maven/</id>
    <published>2018-09-09T03:52:38.000Z</published>
    <updated>2018-09-09T04:05:40.194Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gradle项目打包到maven仓库"><a href="#gradle项目打包到maven仓库" class="headerlink" title="gradle项目打包到maven仓库"></a>gradle项目打包到maven仓库</h2><p>引入插件：</p>
<p>apply plugin: ‘java’</p>
<p>apply plugin: “jacoco”</p>
<p>//maven-publish 插件  提交到本地仓库<br>apply plugin: ‘java-library’</p>
<p>apply plugin: ‘maven’</p>
<p>apply plugin: ‘org.springframework.boot’</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">sourceCompatibility = &apos;1.8&apos;</span><br><span class="line">targetCompatibility = &apos;1.8&apos;</span><br><span class="line"></span><br><span class="line">tasks.withType(JavaCompile) &#123; options.encoding = &apos;UTF-8&apos; &#125;</span><br><span class="line"></span><br><span class="line">group &apos;com.eudemon&apos;</span><br><span class="line">version &apos;0.1.7-SNAPSHOT&apos;</span><br><span class="line"></span><br><span class="line">jacoco &#123;</span><br><span class="line">    toolVersion = &quot;0.8.1&quot;</span><br><span class="line">    reportsDir = file(&quot;$buildDir/customJacocoReportDir&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jacocoTestReport &#123;</span><br><span class="line">    reports &#123;</span><br><span class="line">        xml.enabled false</span><br><span class="line">        csv.enabled false</span><br><span class="line">        html.destination file(&quot;$&#123;buildDir&#125;/jacocoHtml&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">configurations &#123;</span><br><span class="line">    all*.exclude group: &apos;ch.qos.logback&apos;</span><br><span class="line">    all*.exclude module: &apos;slf4j-log4j12&apos;</span><br><span class="line">    all*.exclude module: &apos;slf4j-simple&apos;</span><br><span class="line">    all*.exclude group: &apos;log4j&apos;, module: &apos;log4j&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test &#123;</span><br><span class="line">    useTestNG()</span><br><span class="line">    finalizedBy jacocoTestReport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    //    maven &#123;</span><br><span class="line">    //        url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos;</span><br><span class="line">    //    &#125;</span><br><span class="line">    mavenLocal()</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        springBootVersion = &apos;1.5.6.RELEASE&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 指定上传的路径</span><br><span class="line">//def localMavenRepo = &apos;file://&apos; + new File(System.getProperty(&apos;user.home&apos;), &apos;.m2/repository&apos;).absolutePath</span><br><span class="line">def localMavenRepo = &apos;file:///F:/Env/maven/m2&apos;</span><br><span class="line">// 上传Task，Gradle会生成并上传pom.xml文件。</span><br><span class="line">uploadArchives &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(url: localMavenRepo)</span><br><span class="line">            //构造项目的Pom文件</span><br><span class="line">            pom.project &#123;</span><br><span class="line">                name = project.name</span><br><span class="line">                packaging = &apos;jar&apos;</span><br><span class="line">                description = &apos;description&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile &apos;org.apache.curator:curator-recipes:4.0.0&apos;</span><br><span class="line">    compile &apos;org.slf4j:slf4j-api:1.7.25&apos;</span><br><span class="line">    compile &apos;redis.clients:jedis:2.9.0&apos;</span><br><span class="line">    compile &apos;commons-codec:commons-codec:1.10&apos;</span><br><span class="line">    compile &apos;org.apache.commons:commons-lang3:3.7&apos;</span><br><span class="line">    compile &apos;org.yaml:snakeyaml:1.17&apos;</span><br><span class="line">    compile &apos;com.google.guava:guava:23.0&apos;</span><br><span class="line">    compile &apos;com.fasterxml.jackson.core:jackson-core:2.9.6&apos;</span><br><span class="line">    compile &apos;com.fasterxml.jackson.core:jackson-annotations:2.9.6&apos;</span><br><span class="line">    compile &apos;com.fasterxml.jackson.core:jackson-databind:2.9.6&apos;</span><br><span class="line"></span><br><span class="line">    testCompile &apos;org.testng:testng:6.14.3&apos;</span><br><span class="line">    testCompile &apos;org.hamcrest:hamcrest-library:1.3&apos;</span><br><span class="line">    testCompile &apos;org.hamcrest:hamcrest-core:1.3&apos;</span><br><span class="line">    testCompile &apos;org.mockito:mockito-core:2.18.3&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;gradle项目打包到maven仓库&quot;&gt;&lt;a href=&quot;#gradle项目打包到maven仓库&quot; class=&quot;headerlink&quot; title=&quot;gradle项目打包到maven仓库&quot;&gt;&lt;/a&gt;gradle项目打包到maven仓库&lt;/h2&gt;&lt;p&gt;引入插件：&lt;/p&gt;
&lt;p&gt;apply plugin: ‘java’&lt;/p&gt;
&lt;p&gt;apply plugin: “jacoco”&lt;/p&gt;
&lt;p&gt;//maven-publish 插件  提交到本地仓库&lt;br&gt;apply plugin: ‘java-library’&lt;/p&gt;
&lt;p&gt;apply plugin: ‘maven’&lt;/p&gt;
&lt;p&gt;apply plugin: ‘org.springframework.boot’&lt;/p&gt;
    
    </summary>
    
      <category term="maven" scheme="http://yoursite.com/categories/maven/"/>
    
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>（UML）那么多箭头指来指去，什么意思嘛？</title>
    <link href="http://yoursite.com/2018/09/09/pack/UML/UML%E7%AE%AD%E5%A4%B4%E5%90%AB%E4%B9%89/"/>
    <id>http://yoursite.com/2018/09/09/pack/UML/UML箭头含义/</id>
    <published>2018-09-09T03:52:38.000Z</published>
    <updated>2018-09-09T04:27:07.371Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzUxMzc1MjE3MQ==&amp;mid=2247483663&amp;idx=1&amp;sn=bbf9381f529680041dfe41b2f08d30de&amp;chksm=f9512c0bce26a51d24e14cb7aa9b7c917743091bdcbb89eea17e195ff0660b656bb10f28ad88&amp;token=242075731&amp;lang=zh_CN#rd" target="_blank" rel="external">（UML）那么多箭头指来指去，什么意思嘛？</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMzc1MjE3MQ==&amp;amp;mid=2247483663&amp;amp;idx=1&amp;amp;sn=bbf9381f529680041dfe41b2f08d30de&amp;amp;chksm
    
    </summary>
    
      <category term="UML" scheme="http://yoursite.com/categories/UML/"/>
    
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>react+dva+antd实现CRUD简单功能</title>
    <link href="http://yoursite.com/2017/08/26/react+dva+antd%E5%AE%9E%E7%8E%B0CRUD%E7%AE%80%E5%8D%95%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2017/08/26/react+dva+antd实现CRUD简单功能/</id>
    <published>2017-08-25T22:29:51.000Z</published>
    <updated>2017-08-25T23:34:51.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>确保 node 版本是 6.5 +</li>
<li>用 <a href="https://github.com/cnpm/cnpm" target="_blank" rel="external">cnpm</a> 或 <a href="https://github.com/yarnpkg/yarn" target="_blank" rel="external">yarn</a> 能节约你安装依赖的时间</li>
</ul>
<h1 id="安装dva-clibi并创建应用"><a href="#安装dva-clibi并创建应用" class="headerlink" title="安装dva-clibi并创建应用"></a>安装dva-clibi并创建应用</h1><ul>
<li><p>安装 dva-cli，并确保版本是 0.7 或以上<br>  <code>$ cnpm i dva-cli -g</code></p>
<pre><code>$ dva -v
0.7.0
</code></pre></li>
<li><p>创建应用<br>  <code>$ dva new user-dashboard</code><br>  <code>$ cd user-dashboard</code></p>
</li>
<li><p>启动项目(创建出来的目录根路径)<br>  <code>npm start</code></p>
<a id="more"></a>
</li>
</ul>
<h1 id="配置-antd-和-babel-plugin-import"><a href="#配置-antd-和-babel-plugin-import" class="headerlink" title="配置 antd 和 babel-plugin-import"></a>配置 antd 和 babel-plugin-import</h1><ul>
<li>babel-plugin-import 用于按需引入 antd 的 JavaScript 和 CSS（这样打包出来的文件不至于太大）<br>  <code>cnpm i antd --save</code><br>  <code>cnpm i babel-plugin-import --save-dev</code></li>
<li>修改 .roadhogrc，在 “extraBabelPlugins” 里加上：<br>  <code>[&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: &quot;css&quot; }]</code></li>
</ul>
<h1 id="配置代理，能通过-RESTFul-的方式访问-http-127-0-0-1-8000-api-users"><a href="#配置代理，能通过-RESTFul-的方式访问-http-127-0-0-1-8000-api-users" class="headerlink" title="配置代理，能通过 RESTFul 的方式访问 (http://127.0.0.1:8000/api/users)"></a>配置代理，能通过 RESTFul 的方式访问 (<a href="http://127.0.0.1:8000/api/users" target="_blank" rel="external">http://127.0.0.1:8000/api/users</a>)</h1><ul>
<li><p>修改 .roadhogrc，加上 “proxy” 配置：</p>
<pre><code>&quot;proxy&quot;: {
  &quot;/api&quot;: {
    &quot;target&quot;: &quot;http://jsonplaceholder.typicode.com/&quot;,
    &quot;changeOrigin&quot;: true,
    &quot;pathRewrite&quot;: { &quot;^/api&quot; : &quot;&quot; }
  }
},
</code></pre></li>
<li><p>启动应用：(这个命令一直开着，后面不需要重启)<br>  <code>npm start</code></p>
<h1 id="生成users路由"><a href="#生成users路由" class="headerlink" title="生成users路由"></a>生成users路由</h1></li>
<li>用dva-cli生成路由<br>  <code>dva g route users</code><br>访问：<a href="http://localhost:8000/#/users" target="_blank" rel="external">http://localhost:8000/#/users</a>   立即生效<h1 id="构造users-model和service"><a href="#构造users-model和service" class="headerlink" title="构造users model和service"></a>构造users model和service</h1></li>
<li><p>用dva-cli生成Model<br>  <code>dva g model users</code></p>
<ul>
<li><p>修改 <code>src/models/users.js</code></p>
<pre><code>import * as usersService from &apos;../services/users&apos;;
export default {
  namespace: &apos;users&apos;,
  state: {
    list: [],
    total: null,
    page: null,
  },
  reducers: {
    save(state, { payload: { data: list, total, page } }) {
      return { ...state, list, total, page };
    },
  },
  effects: {
    *fetch({ payload: { page = 1 } }, { call, put }) {
      const { data, headers } = yield call(usersService.fetch, { page });
      yield put({
        type: &apos;save&apos;,
        payload: {
          data,
          total: parseInt(headers[&apos;x-total-count&apos;], 10),
          page: parseInt(page, 10),
        },
      });
    },
    *remove({ payload: id }, { call, put }) {
      yield call(usersService.remove, id);
      yield put({ type: &apos;reload&apos; });
    },
    *patch({ payload: { id, values } }, { call, put }) {
      yield call(usersService.patch, id, values);
      yield put({ type: &apos;reload&apos; });
    },
    *create({ payload: values }, { call, put }) {
      yield call(usersService.create, values);
      yield put({ type: &apos;reload&apos; });
    },
    *reload(action, { put, select }) {
      const page = yield select(state =&gt; state.users.page);
      yield put({ type: &apos;fetch&apos;, payload: { page } });
    },
  },
  subscriptions: {
    setup({ dispatch, history }) {
      return history.listen(({ pathname, query }) =&gt; {
        if (pathname === &apos;/users&apos;) {
          dispatch({ type: &apos;fetch&apos;, payload: query });
        }
      });
    },
  },
};
</code></pre></li>
<li><p>新增 src/services/users.js</p>
<pre><code>import request from &apos;../utils/request&apos;;
import { PAGE_SIZE } from &apos;../constants&apos;;

export function fetch({ page }) {
  return request(`/api/users?_page=${page}&amp;_limit=${PAGE_SIZE}`);
}

export function remove(id) {
  return request(`/api/users/${id}`, {
    method: &apos;DELETE&apos;,
  });
}

export function patch(id, values) {
  return request(`/api/users/${id}`, {
    method: &apos;PATCH&apos;,
    body: JSON.stringify(values),
  });
}

export function create(values) {
  return request(&apos;/api/users&apos;, {
    method: &apos;POST&apos;,
    body: JSON.stringify(values),
  });
}
</code></pre><p>切换到浏览器（会自动刷新），应该没任何变化，因为数据虽然好了，但并没有视图与之关联。但是打开 Redux 开发者工具，应该可以看到 users/fetch 和 users/save 的 action 以及相关的 state 。</p>
</li>
</ul>
</li>
</ul>
<h1 id="添加界面，让用户列表展现出来"><a href="#添加界面，让用户列表展现出来" class="headerlink" title="添加界面，让用户列表展现出来"></a>添加界面，让用户列表展现出来</h1><ul>
<li><p>用dva-cli 生成component<br><code>dva g component Users/Users</code></p>
<p>  然后修改生成出来的 src/components/Users/Users.js 和 src/components/Users/Users.css，并在 src/routes/Users.js 中引用他。</p>
</li>
</ul>
<h1 id="添加layout"><a href="#添加layout" class="headerlink" title="添加layout"></a>添加layout</h1><ul>
<li>添加布局  <code>dva g component MainLayout/MainLayout</code><br><code>src/components/MainLayout/MainLayout.js</code></li>
<li><p>在 <code>src/routes</code> 文件中引用</p>
<pre><code>import React from &apos;react&apos;;
import { connect } from &apos;dva&apos;;
import styles from &apos;./Users.css&apos;;
import UsersComponent from &apos;../components/Users/Users&apos;;
import MainLayout from &apos;../components/MainLayout/MainLayout&apos;;

function Users() {
  return (
   &lt;MainLayout location={location}&gt;
        &lt;div className={styles.normal}&gt;
          &lt;UsersComponent /&gt;
        &lt;/div&gt;
    &lt;/MainLayout&gt;
  );
}

export default connect()(Users);
</code></pre><h1 id="通过-dva-loading-处理-loading-状态"><a href="#通过-dva-loading-处理-loading-状态" class="headerlink" title="通过 dva-loading 处理 loading 状态"></a>通过 dva-loading 处理 loading 状态</h1></li>
<li>安装 dva-loading<br><code>cnpm i dva-loading --save</code></li>
<li><p>修改 src/index.js 加载插件</p>
<pre><code>import createLoading from &apos;dva-loading&apos;;
app.use(createLoading());
</code></pre></li>
<li><p>在 src/components/Users/Users.js 里绑定 loading 数据<br><code>loading: state.loading.models.users,</code></p>
</li>
</ul>
<h1 id="处理分页"><a href="#处理分页" class="headerlink" title="处理分页"></a>处理分页</h1><ul>
<li>更改 <code>src/components/Users/Users.js</code> 文件即可</li>
</ul>
<h1 id="处理用户删除"><a href="#处理用户删除" class="headerlink" title="处理用户删除"></a>处理用户删除</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境准备&quot;&gt;&lt;a href=&quot;#环境准备&quot; class=&quot;headerlink&quot; title=&quot;环境准备&quot;&gt;&lt;/a&gt;环境准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;确保 node 版本是 6.5 +&lt;/li&gt;
&lt;li&gt;用 &lt;a href=&quot;https://github.com/cnpm/cnpm&quot;&gt;cnpm&lt;/a&gt; 或 &lt;a href=&quot;https://github.com/yarnpkg/yarn&quot;&gt;yarn&lt;/a&gt; 能节约你安装依赖的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;安装dva-clibi并创建应用&quot;&gt;&lt;a href=&quot;#安装dva-clibi并创建应用&quot; class=&quot;headerlink&quot; title=&quot;安装dva-clibi并创建应用&quot;&gt;&lt;/a&gt;安装dva-clibi并创建应用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装 dva-cli，并确保版本是 0.7 或以上&lt;br&gt;  &lt;code&gt;$ cnpm i dva-cli -g&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dva -v
0.7.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建应用&lt;br&gt;  &lt;code&gt;$ dva new user-dashboard&lt;/code&gt;&lt;br&gt;  &lt;code&gt;$ cd user-dashboard&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动项目(创建出来的目录根路径)&lt;br&gt;  &lt;code&gt;npm start&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="http://yoursite.com/categories/react/"/>
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>LDAP 默认返回1000用户的坑</title>
    <link href="http://yoursite.com/2017/08/05/LDAP%20%E9%BB%98%E8%AE%A4%E8%BF%94%E5%9B%9E1000%E7%94%A8%E6%88%B7%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2017/08/05/LDAP 默认返回1000用户的坑/</id>
    <published>2017-08-05T06:23:51.000Z</published>
    <updated>2017-08-05T06:48:39.508Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在测试中，常遇到需要测试我们系统的AD/LDAP大用户量展现和下载功能，但win2003server似乎限制该查询数量为1000，使用包括ldap browser在内的工具，也不能将我们AD server上面的10000用户展现完全。</p>
</blockquote>
<p>其实这个问题在微软的网站已经给出了解决方案，在微软网站搜索<code>ad 1000</code>就能找到：</p>
<p><a href="http://support.microsoft.com/kb/315071" target="_blank" rel="external">http://support.microsoft.com/kb/315071</a></p>
<blockquote>
<p>其原因是windows2003server出于性能负荷的考虑，将LDAP查询的数量限制为1000个。当AD中的条目（user/group/ou）数量超过1000条时，使用LDAP查询工具进行查询时，就会导致查询结果返回出错。</p>
</blockquote>
<p>我们所使用的AD用户已超过10000，因此导入用户时，就会有出错信息提示。而且每次最多也只能够展示和导入1000个用户。<br>解决办法可以参见微软网站，这里也作一个记录，以免以后遗忘。步骤如下（建议查看微软网站的描述，其中可控参数描述得很详细）：</p>
<ul>
<li>在“开始”-〉“运行”-〉输入：<code>ntdsutil</code>，回车；</li>
<li>输入：<code>ldap policies</code>,回车；</li>
<li>输入：<code>connections</code>，回车；</li>
<li>输入：<code>connect to domain 当前域名</code>在中集案例中，域名是：cimc.com</li>
<li>连接提示出现后，输入：<code>quit</code>，回车；</li>
<li>输入：<code>show values</code>，确认当前的最大返回数；（默认是1000）</li>
<li>输入：<code>set maxpagesize to 10000</code>，将最大返回数改为10000。（最大返回数可以根据实际情况自行定义）。</li>
<li>再度输入：<code>show values</code>，确认当前的最大返回数（显示为：1000（10000））。</li>
<li>输入<code>commit changes</code>以确认修改。</li>
<li>再次输入：<code>show values</code>，确认当前的最大返回数为10000。</li>
<li>输入<code>quit</code>，退出设置状态；</li>
<li>输入<code>quit</code>，退出当前命令。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在测试中，常遇到需要测试我们系统的AD/LDAP大用户量展现和下载功能，但win2003server似乎限制该查询数量为1000，使用包括ldap browser在内的工具，也不能将我们AD server上面的10000用户展现完全。&lt;/p&gt;
&lt;/
    
    </summary>
    
      <category term="ldap" scheme="http://yoursite.com/categories/ldap/"/>
    
    
      <category term="ldap" scheme="http://yoursite.com/tags/ldap/"/>
    
  </entry>
  
  <entry>
    <title>React 项目生成</title>
    <link href="http://yoursite.com/2017/08/05/React%20%E9%A1%B9%E7%9B%AE%E7%94%9F%E6%88%90/"/>
    <id>http://yoursite.com/2017/08/05/React 项目生成/</id>
    <published>2017-08-05T06:23:51.000Z</published>
    <updated>2017-08-05T06:35:19.814Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>安装node环境，cmd   <code>node -v</code>  检查是否安装</li>
<li>安装yeoman来生成项目基本框架 <code>npm install -g yo</code></li>
<li>运行cmd <code>yo --version</code> 查看版本号</li>
<li>进去 <a href="http://yeoman.io" target="_blank" rel="external">yeoman官网</a> 找到generators</li>
<li>利用generator-react-webpack搭建 <a href="https://github.com/react-webpack-generators/generator-react-webpack" target="_blank" rel="external">generator-react-webpack</a></li>
<li>安装 <code>npm install -g generator-react-webpack</code></li>
<li>查看版本 <code>npm ls -g --depth=1 2&gt;/dev/null | grep generator-</code></li>
<li>生成项目 <code>yo react-webpack gallery-by-react</code></li>
<li>将站点启动 <code>grunt serve</code></li>
<li>打开 <code>https://chrome.google.com/webstore/</code> 应用商店安装 <code>React devloper Tools</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;安装node环境，cmd   &lt;code&gt;node -v&lt;/code&gt;  检查是否安装&lt;/li&gt;
&lt;li&gt;安装yeoman来生成项目基本框架 &lt;code&gt;npm install -g yo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行cmd &lt;code&gt;yo --ver
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优总结 -Xms -Xmx -Xmn -Xss</title>
    <link href="http://yoursite.com/2017/05/20/JVM%E8%B0%83%E4%BC%98%EF%BC%88%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%EF%BC%89%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/20/JVM调优（常用参数）总结/</id>
    <published>2017-05-20T10:30:01.000Z</published>
    <updated>2017-05-20T10:35:08.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆大小设置"><a href="#堆大小设置" class="headerlink" title="堆大小设置"></a>堆大小设置</h3><blockquote>
<p>JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。</p>
</blockquote>
<a id="more"></a>
<ol>
<li><p>典型设置：</p>
<ul>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g    </p>
<p>  -Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。</p>
<p>  -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p>
<p>  -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p>
<p>  -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4          -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p>
<p>  -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</p>
<p>  -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p>
<p>  -XX:MaxPermSize=16m:设置持久代大小为16m。</p>
<p>  -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</p>
</li>
</ul>
</li>
</ol>
<h3 id="回收器选择"><a href="#回收器选择" class="headerlink" title="回收器选择"></a>回收器选择</h3><blockquote>
<p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p>
</blockquote>
<ol>
<li><p>吞吐量优先的并行收集器(适用于科学技术和后台处理等)</p>
<p> (1). 典型配置：</p>
<ul>
<li><p>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:parallelGCThreads=20</p>
<p>  -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p>
<p>  -XX:parallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:parallelGCThreads=20 -XX:+UseParallelOldGC</p>
<p>  -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</p>
<p>  -XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</p>
<p>  -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p>
</li>
</ul>
</li>
<li><p>响应时间优先的并发收集器(适用于应用服务器、电信领域等)</p>
<p> (1). 典型配置：</p>
<ul>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:parallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</p>
<p>  -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</p>
<p>  -XX:+UseParNewGC:设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p>
</li>
<li><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</p>
<p>  -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p>
<p>  -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p>
</li>
</ul>
</li>
</ol>
<h3 id="辅助信息"><a href="#辅助信息" class="headerlink" title="辅助信息"></a>辅助信息</h3><h3 id="常见配置汇总"><a href="#常见配置汇总" class="headerlink" title="常见配置汇总"></a>常见配置汇总</h3><ol>
<li>堆设置<ul>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
</li>
<li>收集器设置<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
</li>
<li>垃圾回收统计信息<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
</li>
<li><p>并行收集器设置</p>
<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
</ul>
</li>
<li><p>并发收集器设置</p>
<ul>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>年轻代大小选择<ul>
<li>响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。</li>
<li>吞吐量优先的应用：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</li>
</ul>
</li>
<li><p>年老代大小选择</p>
<ul>
<li><p>响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p>
<ul>
<li>并发垃圾收集信息</li>
<li>持久代并发收集次数</li>
<li>传统GC信息</li>
<li><p>花在年轻代和年老代回收上的时间比例</p>
<p>减少年轻代和年老代花费的时间，一般会提高应用的效率</p>
</li>
</ul>
</li>
<li>吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</li>
</ul>
</li>
<li><p>较小堆引起的碎片问题</p>
<p> 因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。如果出现“碎片”，可能需要进行如下配置：</p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</li>
<li>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</li>
</ul>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;堆大小设置&quot;&gt;&lt;a href=&quot;#堆大小设置&quot; class=&quot;headerlink&quot; title=&quot;堆大小设置&quot;&gt;&lt;/a&gt;堆大小设置&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;JVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>如何将jar手动安装到maven私服</title>
    <link href="http://yoursite.com/2016/10/15/%E9%9D%9EMaven%E7%9A%84Jar%E8%BD%AC%E6%88%90Maven%E7%9A%84Jar%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/10/15/非Maven的Jar转成Maven的Jar方法/</id>
    <published>2016-10-15T07:00:38.000Z</published>
    <updated>2016-10-15T07:04:54.199Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何将非maven格式jar转成maven格式的jar？"><a href="#如何将非maven格式jar转成maven格式的jar？" class="headerlink" title="如何将非maven格式jar转成maven格式的jar？"></a>如何将非maven格式jar转成maven格式的jar？</h1><blockquote>
<p>目前java项目当中还是依然存在很多不是用maven去管理的项目，但是我们又有很多maven去管理的项目需要引用不是maven管理的项目，怎么办？当然是将不是maven项目管理的jar包转换成maven管理格式的jar包啦。</p>
</blockquote>
<h3 id="Install到本地repo命令"><a href="#Install到本地repo命令" class="headerlink" title="Install到本地repo命令"></a>Install到本地repo命令</h3><pre><code>mvn install:install-file 
-DgroupId=com.microsoft.sqlserver 
-DartifactId=sqljdbc 
-Dversion=4.0.2206 
-Dpackaging=jar 
-Dfile=d:\sqljdbc-4.0.2206.jar
</code></pre><h3 id="deploy到nexus-repo命令"><a href="#deploy到nexus-repo命令" class="headerlink" title="deploy到nexus repo命令"></a>deploy到nexus repo命令</h3><pre><code>mvn deploy:deploy-file 
-DgroupId=com.microsoft.sqlserver 
-DartifactId=sqljdbc 
-Dversion=4.0.2206 
-Dpackaging=jar 
-Dfile=d:\sqljdbc-4.0.2206.jar 
-DrepositoryId=your-nexus-releases-repo 
-Durl=http://yourcorp.com:8081/nexus/content/repositories/yourreleaserepo
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何将非maven格式jar转成maven格式的jar？&quot;&gt;&lt;a href=&quot;#如何将非maven格式jar转成maven格式的jar？&quot; class=&quot;headerlink&quot; title=&quot;如何将非maven格式jar转成maven格式的jar？&quot;&gt;&lt;/a&gt;如何
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>批量修改项目版本号方法（Maven）</title>
    <link href="http://yoursite.com/2016/10/15/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E7%89%88%E6%9C%AC%E5%8F%B7%E6%96%B9%E6%B3%95%EF%BC%88Maven%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/15/批量修改项目版本号方法（Maven）/</id>
    <published>2016-10-15T07:00:38.000Z</published>
    <updated>2016-10-15T07:10:41.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="批量修改项目版本号方法（Maven）"><a href="#批量修改项目版本号方法（Maven）" class="headerlink" title="批量修改项目版本号方法（Maven）"></a>批量修改项目版本号方法（Maven）</h1><blockquote>
<p>基于Maven管理的项目，目前一般的做法都是，如果项目还是处于开发阶段，我们为了方便maven管理，我们一般都是版本号xxx-SNAPSHOT ,为什么这么做呢？假如说，我们等版本稳定了怎么办呢？我们不可能打开每一个pom.xml文件修改每一个版本号把？这太浪费时间和精力了，我们肯定不这么做，下面介绍一种批量更改版本号的方法。</p>
</blockquote>
<h3 id="更改Maven版本号方法"><a href="#更改Maven版本号方法" class="headerlink" title="更改Maven版本号方法"></a>更改Maven版本号方法</h3><pre><code>mvn versions:set -DnewVersion=指定版本号
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;批量修改项目版本号方法（Maven）&quot;&gt;&lt;a href=&quot;#批量修改项目版本号方法（Maven）&quot; class=&quot;headerlink&quot; title=&quot;批量修改项目版本号方法（Maven）&quot;&gt;&lt;/a&gt;批量修改项目版本号方法（Maven）&lt;/h1&gt;&lt;blockquo
    
    </summary>
    
      <category term="Maven" scheme="http://yoursite.com/categories/Maven/"/>
    
    
      <category term="Maven" scheme="http://yoursite.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>SSL证书生成，及在SpringBoot中应用，兼容http和https</title>
    <link href="http://yoursite.com/2016/09/19/SSL%E8%AF%81%E4%B9%A6%E7%94%9F%E6%88%90%EF%BC%8C%E5%8F%8A%E5%9C%A8SpringBoot%E4%B8%AD%E5%BA%94%E7%94%A8%EF%BC%8C%E5%85%BC%E5%AE%B9http%E5%92%8Chttps/"/>
    <id>http://yoursite.com/2016/09/19/SSL证书生成，及在SpringBoot中应用，兼容http和https/</id>
    <published>2016-09-19T12:00:38.000Z</published>
    <updated>2016-09-19T14:34:34.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL证书生成，及在SpringBoot中应用，兼容http和https"><a href="#SSL证书生成，及在SpringBoot中应用，兼容http和https" class="headerlink" title="SSL证书生成，及在SpringBoot中应用，兼容http和https"></a>SSL证书生成，及在SpringBoot中应用，兼容http和https</h1><h3 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h3><p>1、生成密钥库（自签名的证书和私钥）</p>
<pre><code>keytool -genkey -alias mykey -keyalg RSA -keystore keystore.jks
CN=127.0.0.1, OU=PP, O=IT, L=GZ, ST=GD, C=CN  
</code></pre><p>2、查看密钥库</p>
<pre><code>keytool -list -v -keystore keystore.jks
</code></pre><p>3、导出密钥库公钥、信息等到证书中</p>
<pre><code>keytool -export -alias mykey -keystore keystore.jks -storepass 123456 -file scert.cer
</code></pre><a id="more"></a>
<p>4、建立信任密钥库（将服务端证书，导入到客户端的信任密钥库中）</p>
<pre><code>keytool -import -alias  mykey  -file scert.cer -keystore truststore.jks
</code></pre><p>5、查看信任密钥库</p>
<pre><code>keytool -list -v -keystore truststore.jks
</code></pre><p>6、生成客户端的密钥库和证书，客户端证书导入到服务器端</p>
<pre><code>keytool -genkey -alias smsClient -keyalg RSA -keystore ckeystore.jks
keytool -export -alias smsClient -keystore ckeystore.jks -storepass 123456 -file ccert.cer
keytool -import -alias  smsClient  -file ccert.cer -keystore struststore
</code></pre><h3 id="SpringBoot中发布https服务"><a href="#SpringBoot中发布https服务" class="headerlink" title="SpringBoot中发布https服务"></a>SpringBoot中发布https服务</h3><p>1、tomcat.https.properties</p>
<pre><code>custom.tomcat.https.port=8443
custom.tomcat.https.secure=true
custom.tomcat.https.scheme=https
custom.tomcat.https.ssl=true
custom.tomcat.https.password=123456
custom.tomcat.https.alias=smsserver
custom.tomcat.https.store_name=keystore.jks
</code></pre><p>2、WebConfiguration.java</p>
<pre><code>@Configuration
public class WebConfiguration extends WebMvcConfigurerAdapter {

    @Autowired
    private TomcatSslConnectorProperties sslConnectorProperties;

    @Bean
    public EmbeddedServletContainerFactory servletContainer() {
        TomcatEmbeddedServletContainerFactory tomcat = new TomcatEmbeddedServletContainerFactory();
        tomcat.addAdditionalTomcatConnectors(createSslConnector(sslConnectorProperties));
        return tomcat;
    }

    private Connector createSslConnector(TomcatSslConnectorProperties properties) {

        return properties.configureConnector();
    }
}
</code></pre><p>3、TomcatSslConnectorProperties.java</p>
<pre><code>   @ConfigurationProperties(prefix = &quot;custom.tomcat.https&quot;, locations = &quot;classpath:/tomcat.https.properties&quot;)
public class TomcatSslConnectorProperties {
    private Integer port;
    private Boolean ssl = true;
    private Boolean secure = true;
    private String scheme = &quot;https&quot;;
    private String key_store;
    private String password;
    private String alias;

    //shengl省略省略了get set方法

public Connector configureConnector() {
    Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);
    Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();
    try {

        File keystore = new ClassPathResource(key_store).getFile();
        connector.setScheme(scheme);
        connector.setSecure(secure);
        connector.setPort(port);
        protocol.setSSLEnabled(ssl);
        protocol.setKeystoreFile(keystore.getAbsolutePath());
        protocol.setKeystorePass(password);
        protocol.setKeyAlias(alias);
        return connector;
    }
    catch (Exception ex) {
        throw new IllegalStateException(&quot;can&apos;t access keystore: [&quot; + &quot;keystore&quot;
                + &quot;] or truststore: [&quot; + &quot;keystore&quot; + &quot;]&quot;, ex);
    }
}
</code></pre><p>4、 </p>
<pre><code>@SpringBootApplication
@EnableConfigurationProperties({TomcatSslConnectorProperties.class})
public class TianRunMockServer {
    public static void main(String[] args) {
        SpringApplication.run(TianRunMockServer.class, args);
    }
}
</code></pre><h3 id="SpringBoot中请求https服务"><a href="#SpringBoot中请求https服务" class="headerlink" title="SpringBoot中请求https服务"></a>SpringBoot中请求https服务</h3><p>1、main调用</p>
<pre><code>public static void main(String[] args) throws Exception {
        String[] keyInfo = &quot;spring2.jks=123456&quot;.split(&quot;=&quot;);
        String aa = HttpRequestUtil.sslHttpsPost(&quot;https://127.0.0.1:8443/sms/submit&quot;, keyInfo,new UrlEncodedFormEntity(new ArrayList&lt;NameValuePair&gt;(), &quot;UTF-8&quot;));
        System.out.println(aa);
    }
</code></pre><p>2、HttpRequestUtil工具封装</p>
<pre><code>public static String sslHttpsPost(String url, String[] keyInfo, HttpEntity httpEntity) throws Exception {
    HttpClientBuilder builder = HttpClients.custom();
    builder.setSSLContext(SSLHttpClient.getSSLContext(keyInfo[0], keyInfo[1]));
    CloseableHttpClient httpclient = builder.build();
    HttpPost httppost = new HttpPost(url);
    String result = &quot;&quot;;
    try {
        httppost.setEntity(httpEntity);
        CloseableHttpResponse response = httpclient.execute(httppost);
        HttpEntity entity = response.getEntity();
        result = EntityUtils.toString(entity, Consts.UTF_8.name());
    } finally {
        httppost.releaseConnection();
    }
    return result;
}
</code></pre><p>3、SSLContext工具</p>
<pre><code>public static SSLContext getSSLContext(String fileName,String password) throws Exception {
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
    InputStream input = ClassLoader.getSystemResourceAsStream(path);
    ks.load(input, password.toCharArray());

    TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;SunX509&quot;);
    tmf.init(ks);

    SSLContext context = SSLContext.getInstance(&quot;TLSv1.2&quot;);
    // 这里只指定了受信任的证书（单向认证），如果是双向认证的话，则第一个参数不能为null
    context.init(null, tmf.getTrustManagers(), null);
    input.close();
    return context;
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SSL证书生成，及在SpringBoot中应用，兼容http和https&quot;&gt;&lt;a href=&quot;#SSL证书生成，及在SpringBoot中应用，兼容http和https&quot; class=&quot;headerlink&quot; title=&quot;SSL证书生成，及在SpringBoot中应用，兼容http和https&quot;&gt;&lt;/a&gt;SSL证书生成，及在SpringBoot中应用，兼容http和https&lt;/h1&gt;&lt;h3 id=&quot;证书生成&quot;&gt;&lt;a href=&quot;#证书生成&quot; class=&quot;headerlink&quot; title=&quot;证书生成&quot;&gt;&lt;/a&gt;证书生成&lt;/h3&gt;&lt;p&gt;1、生成密钥库（自签名的证书和私钥）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keytool -genkey -alias mykey -keyalg RSA -keystore keystore.jks
CN=127.0.0.1, OU=PP, O=IT, L=GZ, ST=GD, C=CN  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、查看密钥库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keytool -list -v -keystore keystore.jks
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、导出密钥库公钥、信息等到证书中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keytool -export -alias mykey -keystore keystore.jks -storepass 123456 -file scert.cer
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="SSL" scheme="http://yoursite.com/categories/SSL/"/>
    
    
      <category term="SSL" scheme="http://yoursite.com/tags/SSL/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>如何快速搭建自己的GitBook</title>
    <link href="http://yoursite.com/2016/09/10/gitbook%E5%86%99%E4%B9%A6/"/>
    <id>http://yoursite.com/2016/09/10/gitbook写书/</id>
    <published>2016-09-10T04:09:51.000Z</published>
    <updated>2016-09-10T06:59:25.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>对于编程的爱好者来说，都希望凭自己的经验写一些东西分享给业内别的爱好者和记录一些自己的经验，以防日后忘记，也有历史跟踪。GitBook是一个结合GitHub和Markdown来制作精美在线读物的工具。你可以自己或和任何人合作，编著一本在线书籍，还能够销售，当作家不再只是梦。</p>
</blockquote>
<a id="more"></a>
<h2 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h2><ul>
<li>Github账号（用户名、邮箱非常重要）<a href="https://github.com/join" title="注册地址" target="_blank" rel="external">注册地址</a></li>
<li>机器安装Node.js <a href="https://nodejs.org/en/download/" title="NodeJs" target="_blank" rel="external">下载最新版本</a>，默认安装</li>
<li>机器安装Git，<a href="https://git-scm.com/downloads" title="Git安装" target="_blank" rel="external">下载最新版本</a> </li>
<li><p>Hexo安装 </p>
<pre><code>npm install -g hexo
</code></pre><p>注意：如果出现”npm ERR”，则可考虑换成cnpm尝试。</p>
<pre><code>npm install -g cnpm hexo
</code></pre></li>
</ul>
<ul>
<li><p>GitBook安装</p>
<pre><code>npm install -g gitbook-cli  //安装gitbook

gitbook -V //查看gitbook是否安装成功
</code></pre></li>
<li><p>GitBook Editor 书的编写工具，可以看到书的目录（可以不用这个写，个人比较喜欢用MarkDownPad来写）</p>
</li>
<li>MarkDownPad</li>
</ul>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li>GitHub上面创建一个项目，用来保存每次发布的项目，项目名称Repository name：账户名称.github.io（lkun.github.io）</li>
</ul>
<h2 id="GitBook使用"><a href="#GitBook使用" class="headerlink" title="GitBook使用"></a>GitBook使用</h2><h5 id="根据目录生成图书结构"><a href="#根据目录生成图书结构" class="headerlink" title="根据目录生成图书结构"></a>根据目录生成图书结构</h5><ul>
<li>1.1 README.md</li>
</ul>
<blockquote>
<p>readme.md文件相当于一本GitBook的简介。</p>
</blockquote>
<pre><code>D:\&gt;mkdir mygitbookTest
D:\test_gitbook&gt;ECHO xxx&gt;README.md
</code></pre><ul>
<li>1.2 SUMMARY.md</li>
</ul>
<blockquote>
<p>summary.md 是一本书的目录结构.</p>
</blockquote>
<pre><code>D:\test_gitbook&gt;ECHO A&gt;SUMMARY.md
</code></pre><p>输入    </p>
<pre><code># Summary

* [Introduction](README.md)
* [A](a.md)
* [B](b.md)
</code></pre><ul>
<li>1.3 生成图书结构</li>
</ul>
<blockquote>
<p>当这个目录文件创建好之后，我们可以使用Gitbook<br>的命令行工具将这个目录结构生成相应的目录及文件：</p>
</blockquote>
<pre><code>$ gitbook init
</code></pre><p>执行完之后，我们发现gitbook给我们生成了与SUMMARY.md所对应的目录及文件。</p>
<h5 id="生成图书"><a href="#生成图书" class="headerlink" title="生成图书"></a>生成图书</h5><ul>
<li><p>1.1 输出为静态网站</p>
<ul>
<li><p>本地预览时自动生成</p>
<pre><code>#执行命令 

D:\test_gitbook&gt;gitbook serve
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>    Live reload server started on port: 35729
    Press CTRL+C to quit ...

    info: 7 plugins are installed
    info: loading plugin &quot;livereload&quot;... OK
    info: loading plugin &quot;highlight&quot;... OK
    info: loading plugin &quot;search&quot;... OK
    info: loading plugin &quot;lunr&quot;... OK
    info: loading plugin &quot;sharing&quot;... OK
    info: loading plugin &quot;fontsettings&quot;... OK
    info: loading plugin &quot;theme-default&quot;... OK
    info: found 3 pages
    info: found 0 asset files
    info: &gt;&gt; generation finished with success in 2.7s !

    Starting server ...
    Serving book on http://localhost:4000

&gt; 然后,浏览器中输入 http://localhost:4000 就可以预览生
成的以网页形式组织的书籍。
这里你会发现，你在你的图书项目的目录中多了一个名为
_book的文件目录，而这个目录中的文件，即是生成的静态
网站内容。
</code></pre><ul>
<li><p>通过build指定路径手动生成</p>
<pre><code>&gt; 你可以将内容输入到你所想要的目录中去：

   D:\test_gitbook&gt;mkdir temp/gitbook
   D:\test_gitbook&gt;gitbook build --output=D:\test_gitbook\temp\gitbook
</code></pre></li>
</ul>
<h2 id="发布书籍"><a href="#发布书籍" class="headerlink" title="发布书籍"></a>发布书籍</h2><blockquote>
<p>这是最关键的一步了，为了能让自己写好的书在网上能够给别人看到，所以，现在讲上一步build生成的静态网站放在hexo的D:\Books\Hexo\public\2016\08\31目录下，应该也可以放在public的根目录下，还没有试过，比如说你不想放在2016\08\31下，你也可以放在2016\09\10下，这个按照日期来建也是可以的。把文件拷过来了之后，我们就把它push到lkun.github.io这个项目上，然后就可以访问了。</p>
</blockquote>
<p>访问路径：<a href="https://lkun.github.io/2016/08/31/mygitbooktest/index.html" target="_blank" rel="external">https://lkun.github.io/2016/08/31/mygitbooktest/index.html</a></p>
<p>完毕！</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul>
<li><a href="https://lkun.github.io/2016/06/18/hello-world/" title="Hexo配置过程" target="_blank" rel="external">Hexo配置过程</a></li>
<li><a href="https://lkun.github.io/2016/06/18/new-blog-site/" title="博客关联" target="_blank" rel="external">博客关联</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于编程的爱好者来说，都希望凭自己的经验写一些东西分享给业内别的爱好者和记录一些自己的经验，以防日后忘记，也有历史跟踪。GitBook是一个结合GitHub和Markdown来制作精美在线读物的工具。你可以自己或和任何人合作，编著一本在线书籍，还能够销售，当作家不再只是梦。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="GitBook" scheme="http://yoursite.com/categories/GitBook/"/>
    
    
      <category term="GitBook" scheme="http://yoursite.com/tags/GitBook/"/>
    
  </entry>
  
  <entry>
    <title>Flume部署及应用实例</title>
    <link href="http://yoursite.com/2016/08/18/Flume%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2016/08/18/Flume部署及应用实例/</id>
    <published>2016-08-18T14:00:38.000Z</published>
    <updated>2016-08-30T15:37:04.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flume部署及应用实例"><a href="#Flume部署及应用实例" class="headerlink" title="Flume部署及应用实例"></a>Flume部署及应用实例</h1><h3 id="版本下载"><a href="#版本下载" class="headerlink" title="版本下载"></a>版本下载</h3><p><a href="http://www.apache.org/dyn/closer.lua/flume/1.6.0/apache-flume-1.6.0-bin.tar.gz" target="_blank" rel="external">Flume下载地址</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>将下载下来的apache-flume-1.6.0-bin.tar.gz包解压（tar -zxvf apache-flume-1.6.0-bin.tar.gz）到 /opt/目录下面</li>
<li><p>/etc/profile文件下添加</p>
<pre><code>export FLUME_HOME=/opt/apache-flume-1.6.0-bin
export PATH=$PATH:$FLUME_HOME/bin:$FLUME_HOME/conf
</code></pre><a id="more"></a>      </li>
<li><p>验证是否成功</p>
<pre><code>[root@node68 apache-flume-1.6.0-bin]# bin/flume-ng version
Flume 1.6.0
Source code repository: https://git-wip-us.apache.org/repos/asf/flume.git
Revision: 2561a23240a71ba20bf288c7c2cda88f443c2080
Compiled by hshreedharan on Mon May 11 11:15:44 PDT 2015
From source with checksum b29e416802ce9ece3269d34233baf43f
[root@node68 apache-flume-1.6.0-bin]# 
</code></pre><p>注意：出现上面的信息，表示安装成功了.</p>
</li>
</ul>
<h3 id="flume案例"><a href="#flume案例" class="headerlink" title="flume案例"></a>flume案例</h3><ul>
<li>案例一：Syslog</li>
</ul>
<ol>
<li><p>在conf目录下面添加 syslog.conf文件</p>
<p>[root@node68 conf]# pwd<br>/opt/apache-flume-1.6.0-bin/conf<br>[root@node68 conf]# ll<br>total 20<br>-rw-r–r–. 1 cfca games 1661 May  9  2015 flume-conf.properties.template<br>-rw-r–r–. 1 cfca games 1110 May  9  2015 flume-env.ps1.template<br>-rw-r–r–. 1 cfca games 1214 Aug 19 15:05 flume-env.sh.template<br>-rw-r–r–. 1 cfca games 3107 May  9  2015 log4j.properties<br>-rw-r–r–. 1 root root  1689 Aug 19 17:17 syslog.conf<br>[root@node68 conf]# </p>
</li>
</ol>
<p>文件内容为：</p>
<pre><code># The configuration file needs to define the sources, 
# the channels and the sinks.
# Sources, channels and sinks are defined per agent, 
# in this case called &apos;agent&apos;

agent1.sources = r1
agent1.channels = c1
agent1.sinks = k1

# For each one of the sources, the type is defined
agent1.sources.r1.type = syslogtcp
# The channel can be defined as follows.
agent1.sources.r1.channels = c1
agent1.sources.r1.port = 5410
agent1.sources.r1.host = 192.168.1.68

# Each sink&apos;s type must be defined
agent1.sinks.k1.type = logger
#Specify the channel the sink should use
agent1.sinks.k1.channel = c1


# Each channel&apos;s type is defined.
agent1.channels.c1.type = memory

# Other config values specific to each type of channel(sink or source)
# can be defined as well
# In this case, it specifies the capacity of the memory channel
agent1.channels.c1.capacity = 1000
agent1.channels.c1.transactionCapacity = 100
</code></pre><ol>
<li><p>启动flume agent agent1</p>
<pre><code>[root@node68 apache-flume-1.6.0-bin]# bin/flume-ng agent -c conf -f conf/syslog.conf -n agent1 -Dflume.root.logger=INFO,console
</code></pre></li>
</ol>
<ol>
<li><p>测试产生syslog </p>
<pre><code>[root@node68 apache-flume-1.6.0-bin]# echo &quot;hello world syslog&quot; | nc 192.168.1.68 5140
</code></pre></li>
<li><p>控制台信息显示</p>
<pre><code>    2016-08-19 17:41:01,895 (New I/O  worker #1) [WARN - org.apache.flume.source.SyslogUtils.buildEvent(SyslogUtils.java:316)] Event created from Invalid Syslog data.
2016-08-19 17:41:01,903 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:94)] Event: { headers:{Severity=0, Facility=0, flume.syslog.status=Invalid} body: 68 65 6C 6C 6F 20 69 64 6F 61 6C 6C 2E 6F 72 67 hello world }
</code></pre></li>
</ol>
<ul>
<li>案例二：Spool<blockquote>
<p>Spool监测配置的目录下新增的文件，并将文件中的数据读取出来。需要注意两点:1.拷贝到spool目录下的文件不可以再打开编辑。2.spool目录下不可包含相应的子目录</p>
</blockquote>
</li>
</ul>
<ol>
<li>创建agent配置文件（spool.conf）</li>
</ol>
<pre><code>a1.sources = r1
a1.sinks = k1
a1.channels = c1
# Describe/configure the source
a1.sources.r1.type = spooldir
a1.sources.r1.channels = c1
a1.sources.r1.spoolDir = /opt/apache-flume-1.6.0-bin/logs
a1.sources.r1.fileHeader = true
# # Describe the sink
a1.sinks.k1.type = logger
# # Use a channel which buffers events in memory
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100
# # Bind the source and sink to the channel
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1
</code></pre><ol>
<li><p>启动flume agent a1</p>
<pre><code>[root@node68 apache-flume-1.6.0-bin]# flume-ng agent -c conf -f conf/spool.conf -n a1 -Dflume.root.logger=INFO,console
</code></pre></li>
</ol>
<ol>
<li><p>追加文件到 到 /opt/apache-flume-1.6.0-bin/logs 目录</p>
<pre><code>[root@node68 conf]# echo &quot;spool test1&quot; &gt; /opt/apache-flume-1.6.0-bin/logs/spool_text3.log
</code></pre></li>
</ol>
<ol>
<li><p>控制台可看到日志</p>
<pre><code>2016-08-30 08:50:55,628 (pool-3-thread-1) [INFO - org.apache.flume.client.avro.ReliableSpoolingFileEventReader.readEvents(ReliableSpoolingFileEventReader.java:258)] Last read took us just up to a file boundary. Rolling to the next file, if there is one.
2016-08-30 08:50:55,637 (pool-3-thread-1) [INFO - org.apache.flume.client.avro.ReliableSpoolingFileEventReader.rollCurrentFile(ReliableSpoolingFileEventReader.java:348)] Preparing to move file /opt/apache-flume-1.6.0-bin/logs/spool_text3.log to /opt/apache-flume-1.6.0-bin/logs/spool_text3.log.COMPLETED
2016-08-30 08:50:57,106 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:94)] Event: { headers:{file=/opt/apache-flume-1.6.0-bin/logs/spool_text3.log} body: 73 70 6F 6F 6C 20 74 65 73 74 31                spool test1 }
</code></pre></li>
</ol>
<h5 id="参考实例"><a href="#参考实例" class="headerlink" title="参考实例"></a>参考实例</h5><p><a href="https://github.com/pguillebert/logback-flume" target="_blank" rel="external">https://github.com/pguillebert/logback-flume</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Flume部署及应用实例&quot;&gt;&lt;a href=&quot;#Flume部署及应用实例&quot; class=&quot;headerlink&quot; title=&quot;Flume部署及应用实例&quot;&gt;&lt;/a&gt;Flume部署及应用实例&lt;/h1&gt;&lt;h3 id=&quot;版本下载&quot;&gt;&lt;a href=&quot;#版本下载&quot; class=&quot;headerlink&quot; title=&quot;版本下载&quot;&gt;&lt;/a&gt;版本下载&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.apache.org/dyn/closer.lua/flume/1.6.0/apache-flume-1.6.0-bin.tar.gz&quot;&gt;Flume下载地址&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将下载下来的apache-flume-1.6.0-bin.tar.gz包解压（tar -zxvf apache-flume-1.6.0-bin.tar.gz）到 /opt/目录下面&lt;/li&gt;
&lt;li&gt;&lt;p&gt;/etc/profile文件下添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export FLUME_HOME=/opt/apache-flume-1.6.0-bin
export PATH=$PATH:$FLUME_HOME/bin:$FLUME_HOME/conf
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Flume" scheme="http://yoursite.com/categories/Flume/"/>
    
    
      <category term="Flume" scheme="http://yoursite.com/tags/Flume/"/>
    
  </entry>
  
  <entry>
    <title>Flume--日志收集系统之初见</title>
    <link href="http://yoursite.com/2016/08/18/Flume--%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%88%9D%E8%A7%81/"/>
    <id>http://yoursite.com/2016/08/18/Flume--日志收集系统之初见/</id>
    <published>2016-08-18T14:00:38.000Z</published>
    <updated>2016-08-30T15:31:27.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model that allows for online analytic application.</p>
<p>大体意思是说：Flume是一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的日志系统，<br>它有一个简单灵活的架构，这一个架构基于一个数据流。它有可协调的信度机制和故障切换及恢复机制，因而稳健并且可以兼容错误。Flume使用一个简单可扩展的数据模型，这个数据模型允许在线分析的应用。</p>
</blockquote>
<a id="more"></a>
<h3 id="架构图及数据流模型："><a href="#架构图及数据流模型：" class="headerlink" title="架构图及数据流模型："></a>架构图及数据流模型：</h3><ul>
<li>简单</li>
</ul>
<p><img src="http://img2.tuicool.com/3QjQ32.jpg!web" alt="flume1"></p>
<p>Flume的数据流由事件(Event)贯穿始终。事件是Flume的基本数据单位，它携带日志数据(字节数组形式)并且携带有头信息，这些Event由Agent外部的Source，比如上图中的Web Server生成。当Source捕获事件后会进行特定的格式化，然后Source会把事件推入(单个或多个)Channel中。你可以把Channel看作是一个缓冲区，它将保存事件直到Sink处理完该事件。Sink负责持久化日志或者把事件推向另一个Source。<br>很直白的设计，其中值得注意的是，Flume提供了大量内置的Source、Channel和Sink类型。不同类型的Source,Channel和Sink可以自由组合。组合方式基于用户设置的配置文件，非常灵活。比如：Channel可以把事件暂存在内存里，也可以持久化到本地硬盘上。Sink可以把日志写入HDFS, HBase，甚至是另外一个Source等等。    </p>
<p>Flume支持用户建立多级流，也就是说，多个agent可以协同工作，并且支持Fan-in、Fan-out、Contextual Routing、Backup Routes。如下图所示：</p>
<p><img src="http://static.oschina.net/uploads/img/201407/08014622_pD3e.png" alt="flume3"></p>
<ul>
<li>复杂</li>
</ul>
<p><img src="http://img0.tuicool.com/3iQ73aj.jpg!web" alt="Flume2"></p>
<h3 id="8大组件（-components）"><a href="#8大组件（-components）" class="headerlink" title="8大组件（ components）"></a>8大组件（ components）</h3><ul>
<li><p>Event</p>
<blockquote>
<p>An event is a singular unit of data that can be transported by Flume NG. </p>
</blockquote>
</li>
<li><p>Source</p>
<blockquote>
<p>A source of data from which Flume NG receives data.从Client收集数据，传递给Channel。</p>
</blockquote>
</li>
<li><p>Sink</p>
<blockquote>
<p>A sink is the counterpart to the source in that it is a destination for data in Flume NG . 从Channel收集数据，运行在一个独立线程。进行相应的存储文件系统，数据库，或者提交到远程服务器。</p>
</blockquote>
</li>
<li><p>Channel</p>
<blockquote>
<p>A channel is a conduit for events between a source and a sink. 连接 sources 和 sinks ，这个有点像一个队列。主要提供一个队列的功能，对source提供中的数据进行简单的缓存。</p>
</blockquote>
</li>
<li><p>Source and Sink Runners</p>
</li>
<li><p>Agent</p>
<blockquote>
<p>Flume NG generalizes the notion of an agent. An agent is any physical JVM running Flume NG. 使用JVM 运行Flume。每台机器运行一个agent，但是可以在一个agent中包含多个sources和sinks。</p>
</blockquote>
</li>
<li><p>Configuration Provider</p>
</li>
<li><p>Client</p>
<blockquote>
<p>生产数据，运行在一个独立的线程。</p>
</blockquote>
</li>
</ul>
<h3 id="Flume整体架构介绍"><a href="#Flume整体架构介绍" class="headerlink" title="Flume整体架构介绍"></a>Flume整体架构介绍</h3><blockquote>
<p>Flume架构整体上看就是 source–&gt;channel–&gt;sink 的三层架构,，类似生产者和消费者的架构，他们之间通过queue（channel）传输，解耦。看图：</p>
</blockquote>
<p><img src="image/flume1.jpg" alt="flume1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Flume is a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data. It has a simple and flexible architecture based on streaming data flows. It is robust and fault tolerant with tunable reliability mechanisms and many failover and recovery mechanisms. It uses a simple extensible data model that allows for online analytic application.&lt;/p&gt;
&lt;p&gt;大体意思是说：Flume是一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的日志系统，&lt;br&gt;它有一个简单灵活的架构，这一个架构基于一个数据流。它有可协调的信度机制和故障切换及恢复机制，因而稳健并且可以兼容错误。Flume使用一个简单可扩展的数据模型，这个数据模型允许在线分析的应用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="源码分析" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Flume" scheme="http://yoursite.com/tags/Flume/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--策略模式</title>
    <link href="http://yoursite.com/2016/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2016/07/24/设计模式-策略/</id>
    <published>2016-07-24T12:00:38.000Z</published>
    <updated>2016-07-24T12:33:53.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>策略模式 ，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。—抄自百度</p>
</blockquote>
<h3 id="测试-AppMain"><a href="#测试-AppMain" class="headerlink" title="测试 AppMain"></a>测试 AppMain</h3><pre><code>public static void main(String[] args) {
    CashContext cashContext = new CashContext();
    Class&lt;?&gt; cashRebateClass = null;
    String className = &quot;com.sample.demo.designmodule.strategy.shop.CashRebate&quot;;

    try{
        /**
         *
         */
        cashRebateClass = Class.forName(className);
    }catch (Exception e){
        e.printStackTrace();
    }
</code></pre><a id="more"></a>
<pre><code>    CashSuper cashRebate = null;
    CashSuper cashRebate1 = null;
    /**
     * 通过反射获取构造函数，进行初始化
     */
    Constructor&lt;?&gt; constructor[] = cashRebateClass.getConstructors();

    try{
        /**
         * 通过反射获取对象实例
         */
        cashRebate = (CashSuper)constructor[0].newInstance();
        cashRebate1 = (CashSuper)constructor[1].newInstance(0.70);
    }catch (Exception e){

    }

    System.out.println(cashRebate);
    System.out.println(cashRebate1);
    cashContext.setBehavior(cashRebate1);
    //cashContext.setBehavior(cashRebate);
    cashContext.GetResult(20);
}
</code></pre><h3 id="抽象Context，各种抽象子类的桥梁"><a href="#抽象Context，各种抽象子类的桥梁" class="headerlink" title="抽象Context，各种抽象子类的桥梁"></a>抽象Context，各种抽象子类的桥梁</h3><pre><code>public class CashContext {

    private CashSuper cashSuper;

    public void setBehavior(CashSuper cashSuper) {
        this.cashSuper = cashSuper;
    }

    public double GetResult(double money){
        return cashSuper.acceptCash(money);
    }
}
</code></pre><h3 id="策略抽象基类-CashSuper"><a href="#策略抽象基类-CashSuper" class="headerlink" title="策略抽象基类 CashSuper"></a>策略抽象基类 CashSuper</h3><pre><code>public abstract class CashSuper {
    public abstract double acceptCash(double money);
}
</code></pre><h3 id="策略抽象子类-CashNormal"><a href="#策略抽象子类-CashNormal" class="headerlink" title="策略抽象子类 CashNormal"></a>策略抽象子类 CashNormal</h3><pre><code>public class CashNormal extends CashSuper {
    @Override
    public double acceptCash(double money) {
        return money;
    }
}
</code></pre><h3 id="策略抽象子类-CashRebate"><a href="#策略抽象子类-CashRebate" class="headerlink" title="策略抽象子类 CashRebate"></a>策略抽象子类 CashRebate</h3><pre><code>public class CashRebate extends CashSuper {

    private double moneyRebate = 0.8d;

    public CashRebate() {
    }

    public CashRebate(double moneyRebate) {
        this.moneyRebate = moneyRebate;
    }

    @Override
    public double acceptCash(double money) {
        System.out.println(money*moneyRebate);
        return money*moneyRebate;
    }
}
</code></pre><h3 id="策略抽象子类-CashReturn"><a href="#策略抽象子类-CashReturn" class="headerlink" title="策略抽象子类 CashReturn"></a>策略抽象子类 CashReturn</h3><pre><code>public class CashReturn extends CashSuper {

    private double moneyCondition = 0.05d;
    private double moneyReturn = 0.05d;

    public CashReturn(double moneyCondition, double moneyReturn) {
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }

    @Override
    public double acceptCash(double money) {
        double result = money;
        if(money &gt;= moneyCondition){
            result = money - Math.floor(money / moneyCondition) * moneyReturn;
            return result;
        }
        return 0;
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;策略模式 ，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。—抄自百度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试-AppMain&quot;&gt;&lt;a href=&quot;#测试-AppMain&quot; class=&quot;headerlink&quot; title=&quot;测试 AppMain&quot;&gt;&lt;/a&gt;测试 AppMain&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {
    CashContext cashContext = new CashContext();
    Class&amp;lt;?&amp;gt; cashRebateClass = null;
    String className = &amp;quot;com.sample.demo.designmodule.strategy.shop.CashRebate&amp;quot;;

    try{
        /**
         *
         */
        cashRebateClass = Class.forName(className);
    }catch (Exception e){
        e.printStackTrace();
    }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="strategy" scheme="http://yoursite.com/tags/strategy/"/>
    
  </entry>
  
  <entry>
    <title>设计模式--简单工厂</title>
    <link href="http://yoursite.com/2016/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82/"/>
    <id>http://yoursite.com/2016/07/24/设计模式-简单工厂/</id>
    <published>2016-07-24T11:41:38.000Z</published>
    <updated>2016-07-24T11:59:02.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>简单工厂模式，  就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。</p>
</blockquote>
<p>下面以一个计算器的实现举例，简单工厂模式的场景描述：</p>
<blockquote>
<p>+-*/ 等运算不希望混合在一起，因为以后需要扩展的时候，比如说增加一个平方的运算，不希望在同一个方法里面或者同一个类里面去修改，因为这样子的危险性太高了，如果因为增加一个平方的运算，从而影响之前的运算，那肯定不是我们所希望的，所以有简单工厂模式的出现，下面主要是以贴代码为主：</p>
</blockquote>
<h3 id="测试AppMain"><a href="#测试AppMain" class="headerlink" title="测试AppMain"></a>测试AppMain</h3><pre><code>public static void main(String[] args) throws Exception {
    Operation operation = OperationFactory.createOperate(&quot;-&quot;);
    operation.setNumberA(3);
    operation.setNumberB(2);
    double result = operation.getResult();
    System.out.println(result);
}
</code></pre><a id="more"></a>
<h3 id="简单工厂-OperationFactory，是各种运算的桥梁"><a href="#简单工厂-OperationFactory，是各种运算的桥梁" class="headerlink" title="简单工厂 OperationFactory，是各种运算的桥梁"></a>简单工厂 OperationFactory，是各种运算的桥梁</h3><pre><code>public static Operation createOperate(String operate){
Operation oper = null;
switch (operate)
{
    case &quot;+&quot;:
    {
        oper = new OperationAdd();
        break;
    }
    case &quot;-&quot;:
    {
        oper = new OperationSub();
        break;
    }
    case &quot;*&quot;:
    {
        oper = new OperationMul();
        break;
    }
    case &quot;/&quot;:
    {
        oper = new OperationDiv();
        break;
    }
    case &quot;sqr&quot;:
    {
        oper = new OperationSqr();
        break;
    }
    case &quot;sqrt&quot;:
    {
        oper = new OperationSqrt();
        break;
    }
    case &quot;+/-&quot;:
    {
        oper = new OperationReverse();
        break;
    }
}

return oper;
}
</code></pre><h3 id="运算的抽象操作-Operation"><a href="#运算的抽象操作-Operation" class="headerlink" title="运算的抽象操作 Operation"></a>运算的抽象操作 Operation</h3><pre><code>public abstract class Operation {
    private double numberA = 0;
    private double numberB = 0;

    public double getNumberA() {
        return numberA;
    }

    public void setNumberA(double numberA) {
        this.numberA = numberA;
    }

    public double getNumberB() {
        return numberB;
    }

    public void setNumberB(double numberB) {
        this.numberB = numberB;
    }

    /**
     * 抽象获取结果方法，子类实现
     * @return
     * @throws Exception
     */
    public abstract double getResult() throws Exception;
}
</code></pre><h3 id="加法实现抽象-OperationAdd"><a href="#加法实现抽象-OperationAdd" class="headerlink" title="加法实现抽象 OperationAdd"></a>加法实现抽象 OperationAdd</h3><pre><code>public class OperationAdd extends Operation{

    @Override
    public double getResult() {
        double result = 0;
        result = getNumberA() + getNumberB();
        System.out.println(result);
        return result;
    }
}
</code></pre><p>…….</p>
<p>其他的运算一样，具体不贴码了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单工厂模式，  就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面以一个计算器的实现举例，简单工厂模式的场景描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;+-*/ 等运算不希望混合在一起，因为以后需要扩展的时候，比如说增加一个平方的运算，不希望在同一个方法里面或者同一个类里面去修改，因为这样子的危险性太高了，如果因为增加一个平方的运算，从而影响之前的运算，那肯定不是我们所希望的，所以有简单工厂模式的出现，下面主要是以贴代码为主：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试AppMain&quot;&gt;&lt;a href=&quot;#测试AppMain&quot; class=&quot;headerlink&quot; title=&quot;测试AppMain&quot;&gt;&lt;/a&gt;测试AppMain&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
    Operation operation = OperationFactory.createOperate(&amp;quot;-&amp;quot;);
    operation.setNumberA(3);
    operation.setNumberB(2);
    double result = operation.getResult();
    System.out.println(result);
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="factory" scheme="http://yoursite.com/tags/factory/"/>
    
  </entry>
  
  <entry>
    <title>Git使用教程---针对刚入职的同事</title>
    <link href="http://yoursite.com/2016/07/10/Git%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/07/10/Git使用教程/</id>
    <published>2016-07-10T03:23:51.000Z</published>
    <updated>2016-07-10T13:39:52.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、关于版本控制-GIT-SVN"><a href="#一、关于版本控制-GIT-SVN" class="headerlink" title="一、关于版本控制(GIT/SVN)"></a>一、关于版本控制(GIT/SVN)</h3><p>两者都是优秀的版本管理工具</p>
<ul>
<li>Git<blockquote>
<p>git是分布式：服务器和每个开发人员都拥有一个本地的代码管理仓库，进行本地的代码管理；</p>
</blockquote>
</li>
<li>Svn<blockquote>
<p>svn集中式：只有在服务器上有一个代码管理仓库；</p>
</blockquote>
</li>
</ul>
<h3 id="二、Git使用"><a href="#二、Git使用" class="headerlink" title="二、Git使用"></a>二、Git使用</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>使用git进行项目管理和开发，一般情况下，会在服务端（origin）创建一个仓库进行代码的管理，仓库会维护三大块分支。</p>
</blockquote>
<a id="more"></a>
<ul>
<li>master分支：只有一个，作为主分支；</li>
<li>dev分支：项目当前版本的开发分支，程序员会基于此分支 来切 本地分支，进行开发。</li>
<li><p>其他的分支：项目每个版本，在开发测试完成后，最终的稳定代码。每当一个版本的开发测试完成后，都会将当前版本的稳定代码合并到master分支。</p>
</li>
<li><p>说明：假如在开发当前版本时，发现dev7.0.0版本线上出现了bug。此时，就可以基于dev7.0.0分支，进行修复，这是维护其它版本分支最大的好处。</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p> 先安装好Git，配置好SSH，配置SSH的好处就是，本地向服务器push代码时就不用总是填写用户名和密码了，具体操作再说。</p>
<h5 id="1-拉取代码"><a href="#1-拉取代码" class="headerlink" title="(1) 拉取代码"></a>(1) 拉取代码</h5><ul>
<li>git clone 克隆代码</li>
</ul>
<blockquote>
<p>该命令后会在本地生成一个目录，与origin的版本库同名，目录下面包含 .git文件（默认是隐藏的），和服务器上master分支的代码（也有可能没有，因为master分支上一般没有权限获取）；要注意此时是在master分支上的，可以使用 $ git branch 命令查看！ 但是我们是要切dev分支上的代码！</p>
</blockquote>
<pre><code>   lvkun@PC-LVK ~
$ git clone 项目地址
</code></pre><ul>
<li>git checkout dev1.0.0</li>
</ul>
<blockquote>
<p>该命令是将本地版本库（local）切换到dev1.0.0分支，建立local与origin对应分支.此分支可以直接与origin对应分支进行通信。如执行代码的上传(push)和更新（pull）操作. ps(也可以使用 $ git checkout -b dev1.0.0 origin/dev命令代替)    </p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git checkout dev1.0.0
</code></pre><ul>
<li><p>git pull</p>
<blockquote>
<p>该命令将origin/dev1.0.0分支上的代码，pull或更新到local/dev1.0.0 分支上。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git pull
</code></pre></li>
<li><p>git checkout -b 自己的开发分支（feature/项目名_功能_xxx）</p>
</li>
</ul>
<blockquote>
<p>该命令，基于dev1.0.0分支，创建新分支 feature/example_test_local,并切换到 feature/example_test_local分支，一定要创建新分支进行开发，决不能基于本地dev1.0.0分支开发，最后就可以将代码导入开发工具了！此时执行 $ git branch 命令应该可以看到 dev1.0.0 和feature/example_test_local 两个分支。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git checkout -b feature/项目名_功能_xxx
</code></pre><h5 id="2-代码提交"><a href="#2-代码提交" class="headerlink" title="(2) 代码提交"></a>(2) 代码提交</h5><blockquote>
<p>分析：如果一切正常，我们目前应该是在基于本地dev1.0.0分支基础上创建的feature/example_test_local分支上，前面已经说过，本地只有dev1.0.0分支才能与服务器dev分支进行通信，执行代码的pull和push操作。那么我们要做的就是 将 feature/example_test_local分支上的代码，提交到本地dev1.0.0分支上，之后切换到dev1.0.0分支，执行push命令，就ok了！！强烈建议，最好不要将自己的feature/example_test_local这个分支推到自己的远程分之后，直接再推这个分支到远程的dev1.0.0的分支上，如果这样子操作，很可能出现代码拉取下来报错。</p>
</blockquote>
<ul>
<li>git status</li>
</ul>
<blockquote>
<p>此命令可以查看当前分支上有哪些文件改动了，建议首先执行一下，查看改动的文件，避免提交不需要提交的文件。如果想恢复改动的文件，执行 $ git checkout — 文件路径/文件名 。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git status
</code></pre><ul>
<li>git add .</li>
</ul>
<blockquote>
<p>该命令将分支上改动的文件（即工作区改动文件），添加到暂存区，如果增加了新文件最好执行以下这个命令，否则会少上传自己新添的文件，拉取下来报错。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git add .
</code></pre><ul>
<li>git commit -m “修改说明”</li>
</ul>
<blockquote>
<p>将暂存区的文件提交到版本库(dev1.0.0本地版本库)</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git commit -m &quot;xxxxx&quot;
</code></pre><ul>
<li>git checkout dev1.0.0</li>
</ul>
<blockquote>
<p>切换到本地分支 dev1.0.0</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git checkout dev1.0.0
</code></pre><ul>
<li>git pull</li>
</ul>
<blockquote>
<p>该命令将origin/dev1.0.0分支上的代码，更新到local/dev1.0.0 分支上。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git pull
</code></pre><ul>
<li>git checkout feature/example_test_local</li>
</ul>
<blockquote>
<p>该命令切换到本地feature/example_test_local分支</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git checkout feature/example_test_local
</code></pre><ul>
<li>git rebase dev1.0.0</li>
</ul>
<blockquote>
<p>该命令将 dev1.0.0分支上的最新代码，合并到 本地feature/example_test_local分支上。此时很可能会遇到文件冲突的问题，需要到冲突所在的文件下手动修改，修改好后，执行 gitadd.执行 git rebase –continue，此时应该可以成功合并。</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git rebase dev1.0.0
</code></pre><ul>
<li>git push orgin head:refs/for/dev1.0.0</li>
</ul>
<blockquote>
<p>此命令将本地local分支上修改的代码提交到服务器上</p>
</blockquote>
<pre><code>lvkun@PC-LVK ~
$ git push orgin head:refs/for/dev1.0.0
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>在git的使用过程中，提交到远程的dev1.0.0分支的时候，一定要保证代码没有任何的报错，否则的话，到时候大家合并的时候都报错，这是个很严重的问题。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、关于版本控制-GIT-SVN&quot;&gt;&lt;a href=&quot;#一、关于版本控制-GIT-SVN&quot; class=&quot;headerlink&quot; title=&quot;一、关于版本控制(GIT/SVN)&quot;&gt;&lt;/a&gt;一、关于版本控制(GIT/SVN)&lt;/h3&gt;&lt;p&gt;两者都是优秀的版本管理工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git&lt;blockquote&gt;
&lt;p&gt;git是分布式：服务器和每个开发人员都拥有一个本地的代码管理仓库，进行本地的代码管理；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Svn&lt;blockquote&gt;
&lt;p&gt;svn集中式：只有在服务器上有一个代码管理仓库；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;二、Git使用&quot;&gt;&lt;a href=&quot;#二、Git使用&quot; class=&quot;headerlink&quot; title=&quot;二、Git使用&quot;&gt;&lt;/a&gt;二、Git使用&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;使用git进行项目管理和开发，一般情况下，会在服务端（origin）创建一个仓库进行代码的管理，仓库会维护三大块分支。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>模仿HttpEncodingConfiguration创建自定义自动配置,application.properties中的信息自动加载</title>
    <link href="http://yoursite.com/2016/06/26/my-auto-config/"/>
    <id>http://yoursite.com/2016/06/26/my-auto-config/</id>
    <published>2016-06-26T11:09:33.000Z</published>
    <updated>2016-06-26T14:45:28.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Spring Boot封装好的自动配置很简单，在用得很轻松的同时，有没有想过，我们自己的项目中也根据自己的需求写一个具备Spring Boot自动配置功能的冲动呢？首先，来说说Http编码配置的例子，然后参考这个例子，我们自己来实现一个自动配置的功能。</p>
</blockquote>
<h2 id="Http编码配置"><a href="#Http编码配置" class="headerlink" title="Http编码配置"></a>Http编码配置</h2><ul>
<li><p>添加配置，即在 application.properties 上添加：</p>
<pre><code>#HTTP encoding (HttpEncodingProperties)
spring.http.encoding.charset=UTF-8  # the encoding of HTTP request/response
spring.http.encoding.enabled=true #enabled http encoding support
spring.http.encoding.force=true #force the configured encoding
</code></pre></li>
</ul>
<a id="more"></a>
<blockquote>
<p>当然，不一定要”application.properties”这样的文件名，我们可以新建一个”application-myauto.properties”文件，只需要在 @ConfigurationProperties 的属性 locations 里指定properties的位置即可，且需要在入口类上配置。下面举个例子：</p>
</blockquote>
<pre><code>import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
@Component
@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;,locations = {&quot;classpath:config/application-myauto.properties&quot;}) //1
public class MyAutoSettings {
    private String name;
    private Long age;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Long getAge() {
        return age;
    }
    public void setAge(Long age) {
        this.age = age;
    }
}
</code></pre><ul>
<li><p>Spring Boot实现HttpEncoding自动配置的源码如下：</p>
<pre><code>import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)//在 application.properties 配置的时候前缀是 spring.http.encoding
public class HttpEncodingProperties {
    public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);//默认编码方式为UTF-8,若修改可使用 spring.http.encoding.charset=编码
    private Charset charset = DEFAULT_CHARSET;
    private boolean force = true;//设置 forceEncoding,默认为true，若修改可使用 spring.http.encoding.force=false

    public Charset getCharset() {    
        return this.charset;
    }
    public void setCharset(Charset charset) {
        this.charset = charset;
    }
    ....
}
</code></pre></li>
<li><p>配置Bean，根据条件配置CharsetEncodingFilter的Bean</p>
<pre><code>@Configuration
@EnableConfigurationProperties(HttpEncodingProperties.class)//开启属性注入，通过@EnableConfigurationProperties 声明，使用 @Autowired注入
@ConditionalOnClass(CharacterEncodingFilter.class)//当CharacterEncodingFilter在类路径的条件下
@ConditionalOnProperties(prefix = &quot;spring.http.encoding&quot;,value = &quot;enabled&quot;,matchIfMissing = true)//当设置 spring.http.encoding = enabled 的情况下，如果没有设置则默认为true,即条件符合；
public class HttpEncodingAutoConfiguration {

    @Autowired
    private HttpEncodingProperties httpEncodingProperties;

    @Bean // 像使用Java 配置的方式配置CharacterEncodingFilter 这个Bean
    @ConditionalOnMissingBean(CharacterEncodingFilter.class)//当容器中没有这个Bean的时候新建Bean
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.httpEncodingProperties.getCharset().name());
        filter.setForceEncoding(this.httpEncodingProperties.isForce());
        return filter;
    }
}
</code></pre></li>
</ul>
<h2 id="MyAutoConfig配置"><a href="#MyAutoConfig配置" class="headerlink" title="MyAutoConfig配置"></a>MyAutoConfig配置</h2><blockquote>
<p>下面就来创建一个我们自己项目的自动配置。</p>
</blockquote>
<ul>
<li><p>依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre></li>
<li><p>属性配置</p>
<p>  1.application.properties中填入：</p>
<pre><code>app.name=jmust
app.source=wx
</code></pre><p>  2.配置类</p>
<pre><code>@ConfigurationProperties(prefix=&quot;app&quot;)
public class MyAutoPrpperties {
    private static final String NAME = &quot;jmust&quot;;
    private String name = NAME;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><p>  在 application.properties 中通过 app.name= 来设置，默认为 app.name = jmust</p>
</li>
<li><p>判断依据</p>
</li>
</ul>
<pre><code>/**
 * Created by LK on 2016/6/26.
 */
public class MyAutoService {
    private String name;

    public String sayName(){
        return &quot;zzz&quot;+ name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</code></pre><ul>
<li><p>自动配置</p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Created by LK on 2016/6/26.
 */

@Configuration
@EnableConfigurationProperties(MyAutoProperties.class)
@ConditionalOnClass(MyAutoService.class)
@ConditionalOnProperty(prefix=&quot;app&quot;,value = &quot;enabled&quot;,matchIfMissing = true)
public class MyAutoServiceAutoConfiguration {

    @Autowired
    private MyAutoProperties myAutoProperties;

    @Bean
    @ConditionalOnMissingBean(MyAutoService.class)
    public MyAutoService myAutoService(){
        MyAutoService myAutoService = new MyAutoService();
        myAutoService.setName(myAutoProperties.getName());
        return myAutoService;
    }
}
</code></pre></li>
<li><p>注册配置</p>
</li>
</ul>
<blockquote>
<p>如果想自动配置生效，需要注册自动配置类。在src/main/resources 下新建META-INF/spring.factories,在spring.factories中填如下内容注册：</p>
</blockquote>
<pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.jmust.service.demo.MyAutoServiceAutoConfiguration
</code></pre><ul>
<li><p>使用    </p>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Created by LK on 2016/6/26.
 */
@RestController
@SpringBootApplication
public class DemoApplication {

    @Autowired
    private MyAutoService myAutoService;

    @RequestMapping(&quot;/&quot;)
    public String index(){
        return myAutoService.sayName();
    }

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class,args);
    }
}
</code></pre><p>  在项目中可以直接注入MyAutoService的Bean,但是项目中我们并没有配置这个 Bean,这就是通过自动配置完成的。</p>
</li>
<li><p>效果</p>
<p>  访问 <a href="http://localhost:8080,就会出现你在application.properties中对应name的内容了。" target="_blank" rel="external">http://localhost:8080,就会出现你在application.properties中对应name的内容了。</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Spring Boot封装好的自动配置很简单，在用得很轻松的同时，有没有想过，我们自己的项目中也根据自己的需求写一个具备Spring Boot自动配置功能的冲动呢？首先，来说说Http编码配置的例子，然后参考这个例子，我们自己来实现一个自动配置的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Http编码配置&quot;&gt;&lt;a href=&quot;#Http编码配置&quot; class=&quot;headerlink&quot; title=&quot;Http编码配置&quot;&gt;&lt;/a&gt;Http编码配置&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;添加配置，即在 application.properties 上添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#HTTP encoding (HttpEncodingProperties)
spring.http.encoding.charset=UTF-8  # the encoding of HTTP request/response
spring.http.encoding.enabled=true #enabled http encoding support
spring.http.encoding.force=true #force the configured encoding
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Spring-Boot" scheme="http://yoursite.com/categories/Spring-Boot/"/>
    
    
      <category term="Spring-Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot自定义RabbitMQ配置实例</title>
    <link href="http://yoursite.com/2016/06/26/custom-rabbitmq-config/"/>
    <id>http://yoursite.com/2016/06/26/custom-rabbitmq-config/</id>
    <published>2016-06-25T18:53:01.000Z</published>
    <updated>2016-06-25T20:25:55.677Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。下面通过一个实例来说明一下怎么去使用它，怎么体现出它的优势所在：</p>
</blockquote>
<a id="more"></a>
<p>由于我是基于Spring Boot的来说明rabbitMQ的使用，所以首先我们需要配置好rabbitMQ。</p>
<h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;version&gt;${springboot.version}&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
</code></pre><h2 id="配置文件准备"><a href="#配置文件准备" class="headerlink" title="配置文件准备"></a>配置文件准备</h2><p>在 src/main/resources/下面添加如下properties文件：</p>
<ul>
<li><p>application.properties</p>
<pre><code>spring.profiles.active=@profiles.active@
rabbitMQ.host=${rabbitMQ.host}
rabbitMQ.port=${rabbitMQ.port}
rabbitMQ.username=${rabbitMQ.username}
rabbitMQ.password=${rabbitMQ.password}
rabbitMQ.exchange=${rabbitMQ.exchange}
</code></pre></li>
<li><p>application-develop.properties(测试用)</p>
<pre><code>rabbitMQ.host=192.168.100.117
rabbitMQ.port=5672
rabbitMQ.username=guest
rabbitMQ.password=guest
rabbitMQ.exchange=xxx.xxx.xxx
</code></pre></li>
<li><p>application-production.properties（生产用）</p>
<pre><code>rabbitMQ.host=192.168.100.117
rabbitMQ.port=5672
rabbitMQ.username=guest
rabbitMQ.password=guest
rabbitMQ.exchange=xxx.xxx.xxx
</code></pre></li>
</ul>
<h2 id="RabbitMQ自定义配置文件实现"><a href="#RabbitMQ自定义配置文件实现" class="headerlink" title="RabbitMQ自定义配置文件实现"></a>RabbitMQ自定义配置文件实现</h2><p>在src/main/java/com.jmust.service.demo下创建”RabbitMQConfiguration.java”文件</p>
<pre><code>import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;

@Configuration
public class RabbitMQConfiguration {
    @Autowired
    private Environment env;

    @Bean
    public RabbitTemplate instance() {
        com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = new com.rabbitmq.client.ConnectionFactory();
        rabbitConnectionFactory.setUsername(env.getProperty(&quot;rabbitMQ.username&quot;));
        rabbitConnectionFactory.setPassword(env.getProperty(&quot;rabbitMQ.password&quot;));
        rabbitConnectionFactory.setHost(env.getProperty(&quot;rabbitMQ.host&quot;));
        rabbitConnectionFactory.setPort(Integer.parseInt(env.getProperty(&quot;rabbitMQ.port&quot;)));

        ConnectionFactory connectionFactory = new CachingConnectionFactory(rabbitConnectionFactory);
        RabbitTemplate rabbitTemplate = new RabbitTemplate();
        rabbitTemplate.setConnectionFactory(connectionFactory);
        rabbitTemplate.setExchange(env.getProperty(&quot;rabbitMQ.exchange&quot;));
        return rabbitTemplate;
    }
}
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>1、自定义接口类（DemoMQResource）src/main/com.jmust.service.demo.resource，定义操作契约</p>
<pre><code>import com.jmust.service.demo.resource.entity.DemoToMQ;

    @FunctionalInterface
    public interface DemoMQResource {

        void sendDemoMQ(DemoToMQ demoToMQ);
    }
</code></pre></li>
<li><p>2、实现接口类，业务逻辑包含在内(src/main/com.jmust.service.demo.resource)</p>
<pre><code>import com.jmust.server.profile.ProfileProduction;
import com.jmust.service.demo.LogFailMqUtil;
import com.jmust.service.demo.resource.entity.DemoToMQ;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageDeliveryMode;
import org.springframework.amqp.core.MessageProperties;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;

@Component
@ProfileProduction
public class DemoMQResourceImpl implements DemoMQResource {

    private static Logger logger = LoggerFactory.getLogger(DemoMQResourceImpl.class);
    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Override
    public void sendDemoMQ(DemoToMQ demoToMQ) {
        //发送mq
        MessageProperties messageProperties = new MessageProperties();
        messageProperties.setDeliveryMode(MessageDeliveryMode.PERSISTENT);
        messageProperties.setContentEncoding(&quot;JSON&quot;);
        messageProperties.setContentType(
                &quot;xxx.xxx.xxx, xxx.xxx, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;);

        String body = demoToMQ.toString();
        Message message = new Message(body.getBytes(StandardCharsets.UTF_8), messageProperties);
        try {
            rabbitTemplate.send(message);
            logger.info(&quot;send success to mq:{}&quot;, body);
        } catch (Exception e) {
            logger.error(&quot;send fail to mq:&quot;, e);
        }
    }
}
</code></pre></li>
</ul>
<h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><pre><code>import com.jmust.service.demo.resource.entity.DemoToMQ;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import static org.mockito.Matchers.any;
import static org.mockito.Mockito.doThrow;

public class DemoMQResourceTest {

    @InjectMocks
    private DemoMQResourceImpl demoMQResourceImpl;

    @Mock
    private RabbitTemplate rabbitTemplate;

    @BeforeClass
    public void init() {
        demoMQResourceImpl = new DemoMQResourceImpl();
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void sendMq() {
        doThrow(new RuntimeException(&quot;send  mq  is  validate&quot;)).when(rabbitTemplate).send(any(Message.class));
        demoMQResourceImpl.sendDemoMQ(new DemoToMQ());
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MQ是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取或者订阅队列中的消息。下面通过一个实例来说明一下怎么去使用它，怎么体现出它的优势所在：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="rabbitMQ" scheme="http://yoursite.com/categories/rabbitMQ/"/>
    
    
      <category term="Spring-Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="rabbitMQ" scheme="http://yoursite.com/tags/rabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot自定义Mybatis配置实例</title>
    <link href="http://yoursite.com/2016/06/26/custom-mybatis-config/"/>
    <id>http://yoursite.com/2016/06/26/custom-mybatis-config/</id>
    <published>2016-06-25T18:52:38.000Z</published>
    <updated>2016-06-25T20:26:08.258Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。随着2013年开源以来，目前业内使用的也越来越多。下面通过一个实例来说明一下怎么去使用它，怎么体现出它的优势所在：</p>
</blockquote>
<a id="more"></a>
<p>由于我是基于Spring Boot的来说明mybatis的使用，所以首先我们需要配置好mybatis。</p>
<h2 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h2><pre><code>&lt;!--依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;9.4.1208&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;4.2.6.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.0.20&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    &lt;version&gt;1.4.192&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h2 id="配置文件准备"><a href="#配置文件准备" class="headerlink" title="配置文件准备"></a>配置文件准备</h2><p>在 src/main/resources/下面添加如下properties文件：</p>
<ul>
<li><p>application.properties</p>
<pre><code>spring.profiles.active=@profiles.active@
jdbc.url=${jdbc.url}
jdbc.username= ${jdbc.username}
jdbc.password= ${jdbc.password}
jdbc.driver=${jdbc.driver}
jdbc.poolMaximumActiveConnections=${jdbc.poolMaximumActiveConnections}
jdbc.poolMaximumIdleConnections=${jdbc.poolMaximumIdleConnections}
</code></pre></li>
<li><p>application-develop.properties(测试用)</p>
<pre><code>jdbc.url=jdbc:h2:mem:demo-db;MODE=PostgreSQL;INIT=RUNSCRIPT FROM &apos;./src/test/resources/sql/demo.sql&apos;
jdbc.username= sa
jdbc.password= sa
jdbc.driver= org.h2.Driver
jdbc.poolMaximumActiveConnections=20
jdbc.poolMaximumIdleConnections=0
</code></pre></li>
<li><p>application-production.properties（生产用）</p>
<pre><code>jdbc.url=jdbc:postgresql://192.168.100.117:5432/db_demo?characterEncoding#UTF-8
jdbc.username= postgres
jdbc.password= postgres
jdbc.driver=org.postgresql.Driver
jdbc.poolMaximumActiveConnections=30
jdbc.poolMaximumIdleConnections=0
</code></pre></li>
</ul>
<h2 id="Mybatis自定义配置文件实现"><a href="#Mybatis自定义配置文件实现" class="headerlink" title="Mybatis自定义配置文件实现"></a>Mybatis自定义配置文件实现</h2><p>在src/main/java/com.jmust.service.demo下创建”MybatisConfiguration.java”文件</p>
<pre><code>import com.alibaba.druid.pool.DruidDataSource;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import javax.annotation.PostConstruct;
import javax.sql.DataSource;

@Configuration
@MapperScan(basePackages = {&quot;com.jmust.service.demo.resource.mapper&quot;})
public class MybatisConfiguration {

    @Autowired
    private Environment env;

    @Autowired
    private DataSource pooledDataSource;
    private static Log logger = LogFactory.getLog(MybatisConfiguration.class);

    @PostConstruct
    @Bean
    public DataSource dataSource() {
        DruidDataSource druidDataSource = new DruidDataSource();
        druidDataSource.setPassword(env.getProperty(&quot;jdbc.password&quot;));
        druidDataSource.setUsername(env.getProperty(&quot;jdbc.username&quot;));
        druidDataSource.setUrl(env.getProperty(&quot;jdbc.url&quot;));
        druidDataSource.setDriverClassName(env.getProperty(&quot;jdbc.driver&quot;));
        druidDataSource.setMaxActive(Integer.parseInt(env.getProperty(&quot;jdbc.poolMaximumActiveConnections&quot;)));
        return druidDataSource;
    }

    @Bean
    public SqlSessionFactory sqlSessionFactory() {
        try {
            SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean();
            sessionFactory.setDataSource(pooledDataSource);
            sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver()
                    .getResources(&quot;classpath:mapping/*.xml&quot;));

            return sessionFactory.getObject();
        } catch (Exception e) {
            logger.error(&quot;not install sessionFactory&quot;, e);
            throw new RuntimeException(&quot;not install sessionFactory&quot;);
        }
    }

    @Bean
    public DataSourceTransactionManager transaction() {
        return new DataSourceTransactionManager(pooledDataSource);
    }
}
</code></pre><h2 id="Mybatis代码生成"><a href="#Mybatis代码生成" class="headerlink" title="Mybatis代码生成"></a>Mybatis代码生成</h2><ul>
<li>1、生成xxxMapper.java接口文件(src/main/com.jmust.service.demo.resource.mapper)，该文件主要作用是映射到xxxMapper.xml文件中的操作标签的（比如insert对应xml文件中的<insert>）</insert></li>
<li><pre><code>import com.jmust.service.demo.resource.entity.Demo;
import org.springframework.stereotype.Repository;
import java.util.Date;

@Repository
public interface DemoMapper {
    Demo select(long customerId);   
    boolean insert(Demo demoPojo);  
    boolean update(Demo demoPojo);
}
</code></pre></li>
<li><p>2、生成xxxMapper.xml文件(src/main/resources/mapping/)，该文件的主要作用就是操作数据（插入、更改、删除……）语句的维护及管理</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;

&lt;mapper namespace=&quot;com.jmust.service.demo.resource.mapper.DemoMapper&quot;&gt;

&lt;resultMap id=&quot;demoPojo&quot; type=&quot;com.jmust.service.demo.resource.entity.Demo&quot;&gt;
    &lt;result column=&quot;customer_id&quot; property=&quot;customerId&quot;/&gt;
    &lt;result column=&quot;total_times&quot; property=&quot;totalTimes&quot;/&gt;
    &lt;result column=&quot;continue_days&quot; property=&quot;continueDays&quot;/&gt;
    &lt;result column=&quot;last_time&quot; property=&quot;lastTime&quot;/&gt;
&lt;/resultMap&gt;
</code></pre></li>
</ul>
<pre><code>    &lt;select id=&quot;select&quot; resultMap=&quot;demoPojo&quot; parameterType=&quot;long&quot;&gt;
        SELECT * FROM demo
        WHERE customer_id = #{customerId}
    &lt;/select&gt;

    &lt;insert id=&quot;insert&quot; parameterType=&quot;com.jmust.service.demo.resource.entity.Demo&quot;&gt;
        insert into demo(customer_id,total_times,continue_days,last_time)
        values
        (#{customerId},1,#{continueDays},#{lastTime},#{awardType})
    &lt;/insert&gt;

    &lt;update id=&quot;update&quot; parameterType=&quot;com.jmust.service.demo.resource.entity.Demo&quot;&gt;
        update demo
        &lt;set&gt;
            &lt;if test=&quot;continueDays != null&quot;&gt;
                continue_days = #{continueDays},
            &lt;/if&gt;
            &lt;if test=&quot;awardType != null&quot;&gt;
                award_type = #{awardType},
            &lt;/if&gt;
            &lt;if test=&quot;lastTime != null&quot;&gt;
                last_time = #{lastTime}
            &lt;/if&gt;
        &lt;/set&gt;
        where customer_id = #{customerId}
    &lt;/update&gt;

&lt;/mapper&gt;
</code></pre><ul>
<li><p>3、自定义接口类（DemoResources）src/main/com.jmust.service.demo.resource，定义操作契约</p>
<pre><code>import com.jmust.service.demo.resource.entity.Demo;
import java.util.Date;

public interface DemoResources {
     Demo queryDemo(long customerId);
     void update(Demo demoinPojo);
     void insert(Demo demoPojo);
}
</code></pre></li>
<li><p>4、实现接口类，业务逻辑包含在内(src/main/com.jmust.service.demo.resource)</p>
<pre><code>import com.jmust.contract.ExtendedStatusRuntimeException;
import com.jmust.contract.ResourceUnavailableException;
import com.jmust.service.demo.DemoStatus;
import com.jmust.service.demo.resource.entity.Demo;
import com.jmust.service.demo.resource.mapper.DemoMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
public class DemoResourcesImpl implements DemoResources{
    @Autowired
    private DemoMapper demoMapper;
    @Override
    public Demo queryDemo(long customerId) {
        try {
            return demoMapper.select(customerId);
        }catch (Exception e){
            throw new ResourceUnavailableException(&quot;Database fail select Demo&quot;,e);
        }
    }

    @Override
    public void update(Demo demoPojo) {
        try {
            if(!demoMapper.update(demoPojo)){
                throw new ExtendedStatusRuntimeException(101, &quot;Demo process  fail  ,because Demo   update fail&quot;);
            }
        }catch (Exception e){
            throw new ResourceUnavailableException(&quot;Database fail update demoPojo&quot;,e);
        }
    }

    @Override
    public void insert(Demo demo) {
        try {
            if(!demoMapper.insert(demo)){
                throw new ExtendedStatusRuntimeException(102, &quot;demo process  fail  ,because demo insert  fail&quot;);
            }
        }catch (DuplicateKeyException e){
            if(!DemoMapper.update(demo)){
                throw new ExtendedStatusRuntimeException(102, &quot;demo process  fail  &quot; +
                        &quot;,because demo update  fail&quot;);
            }
        }catch (Exception e){
            throw new ResourceUnavailableException(&quot;Database fail insert demoPojo &quot;,e);
        }
    }

}
</code></pre></li>
</ul>
<h2 id="项目测试"><a href="#项目测试" class="headerlink" title="项目测试"></a>项目测试</h2><pre><code>import com.jmust.server.profile.ProfileDevelop;
import com.jmust.server.profile.ProfileTest;
import com.jmust.service.demo.DemoConstants;
import com.jmust.service.demo.MybatisConfiguration;
import com.jmust.service.demo.resource.entity.Demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.testng.AbstractTestNGSpringContextTests;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Test;

import java.sql.Timestamp;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@ProfileTest
@ProfileDevelop
@ContextConfiguration(classes = {MybatisConfiguration.class, DemoResourcesImpl.class})
@TestPropertySource(value = &quot;classpath:application.properties&quot;)
public class DemoPojoResourcesTest extends AbstractTestNGSpringContextTests {
    private Long concurrent = System.currentTimeMillis();
    private int customerId = 11;

    @Autowired
    private DemoResources cm;

    @BeforeClass
    public void insert() {
        Demo demoPojo = new Demo();
        demoPojo.setCustomerId(customerId);
        demoPojo.setCreateTime(new Timestamp(concurrent));
        demoPojo.setAwardTypeEnum(&quot;&quot;);
        demoPojo.setTotalTimes(0);
        cm.insert(demoPojo);
    }

    @Test
    public void queryDemo() {
        Demo demoPojo = cm.queryDemo(customerId);
        assertThat(demoPojo.getCustomerId()).isEqualTo(customerId);
        assertThat(demoPojo.getCreateTime()).isEqualTo(new Timestamp(concurrent));
        assertThat(demoPojo.getTotalTimes()).isEqualTo(1);
    }
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。随着2013年开源以来，目前业内使用的也越来越多。下面通过一个实例来说明一下怎么去使用它，怎么体现出它的优势所在：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mybatis" scheme="http://yoursite.com/categories/mybatis/"/>
    
    
      <category term="Spring-Boot" scheme="http://yoursite.com/tags/Spring-Boot/"/>
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Mockito+Testng+Assertj的使用实例</title>
    <link href="http://yoursite.com/2016/06/26/mockito-testng-assertj/"/>
    <id>http://yoursite.com/2016/06/26/mockito-testng-assertj/</id>
    <published>2016-06-25T17:30:44.000Z</published>
    <updated>2016-06-25T18:48:18.342Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>写测试用例时，如果只关注输入、输出或是否被调用，建议使用Mock框架，能使用Mock的框架有EasyMock、Mockito、PowerMock、JMock等；</p>
<p>Mock框架在处理”黑洞”接口，有特别的效果，</p>
<p>下面来分享下Mockito框架的使用：</p>
</blockquote>
<a id="more"></a>
<p>假如说我现在项目有三层，</p>
<ul>
<li>第一层是入口层，我把它叫做”access”;</li>
<li>第二层是业务处理层，我把它叫做”business”;</li>
<li>第三层是数据处理层，我把她叫做”resource”;</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><blockquote>
<p>是指对软件中的最小可测试单元进行检查和验证。</p>
</blockquote>
<p>现在我分情况来说明一下怎么利用Mockito框架去进行Mock测试；</p>
<h4 id="单独测试access层，跳过business和resource层"><a href="#单独测试access层，跳过business和resource层" class="headerlink" title="单独测试access层，跳过business和resource层"></a>单独测试access层，跳过business和resource层</h4><blockquote>
<p>只需要把business层Mock掉就可以了，因为resource层是有business层去调用，所以不必理会，下面上例子：</p>
</blockquote>
<pre><code>import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.testng.annotations.AfterMethod;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;
import java.util.Date;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Mockito.*;

public class ServiceAccessTest {
private  int customerId = 2;
private int invalidCustomerId =0;

@Mock
private DemoBusiness demoBusiness; //需要Mock的business层

@Mock
private StreamObserver&lt;DemoResponse&gt; demoSO;

@InjectMocks
DemoServiceAccess demoServiceAccess;//需要测试的access层

//跑测试前要进行的初始化
@BeforeMethod
public void setup() {
    demoServiceAccess = new DemoServiceAccess();
    MockitoAnnotations.initMocks(this);
}

//测试跑完后需要做的事情
@AfterMethod
public void after() {
    reset(demoBusiness, demoSO);
    reset(demoBusiness, helpDemoSO);
    reset(demoBusiness, getDemoLogSO);
}

@Test
public void DemoTest_Success() {
    DemoBusinessPojo demoPojo = new DemoBusinessPojo();
    demoPojo.setContinueDays(5);
    demoPojo.setIncreaseScore(5);
    demoPojo.setLastTime(new Date().getTime());
    demoPojo.setTotalTimes(11);
    when(demoBusiness.summit(customerId)).thenReturn(demoPojo);

    ArgumentCaptor&lt;DemoResponse&gt; ac = ArgumentCaptor.forClass(DemoResponse.class);
    demoServiceAccess.summit(DemoRequest.newBuilder().setCustomerId(customerId).build(), demoSO);
    verify(demoSO).onNext(ac.capture());
    reset(demoBusiness);
}

@Test(expectedExceptions = InvalidArgumentException.class)
public void DemoFailTest() {
    demoServiceAccess.summit(DemoRequest.newBuilder().setCustomerId(invalidCustomerId).build(), demoSO);
}

@SuppressWarnings(&quot;unchecked&quot;)
@Test(expectedExceptions = StatusRuntimeException.class)
public void DemoFailTest1() {
    when(demoBusiness.summit(customerId)).thenThrow(ResourceUnavailableException.class);
    demoServiceAccess.summit(DemoRequest.newBuilder().setCustomerId(customerId).build(), demoSO);
}

@SuppressWarnings(&quot;unchecked&quot;)
@Test(expectedExceptions = Exception.class)
public void DemoFailTest2() {
    when(demoBusiness.summit(customerId)).thenThrow(Exception.class);
    demoServiceAccess.summit(DemoRequest.newBuilder().setCustomerId(customerId).build(), demoSO);
}
</code></pre><h4 id="单独测试business层，跳过resource层"><a href="#单独测试business层，跳过resource层" class="headerlink" title="单独测试business层，跳过resource层"></a>单独测试business层，跳过resource层</h4><blockquote>
<p>因为是单元测试，所以之前的access层我们也不必去理会了，从而只Mock层就OK了，下面上例子：</p>
</blockquote>
<pre><code>import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests;
import org.testng.annotations.Test;
import java.util.Date;
import java.util.concurrent.atomic.AtomicInteger;
import static org.assertj.core.api.Assertions.assertThat;


@ProfileTest
@ProfileDevelop //环境为dev
@ContextConfiguration(classes = {DemoBusiness.class})//加载类，如果有多个类，可以用&quot;,&quot;隔开，往后添加
@TestPropertySource(value = &quot;classpath:application.properties&quot;)//加载配置文件
public class DemoBusinessTest extends AbstractTransactionalTestNGSpringContextTests {

    @Autowired
    private DemoBusiness demoBusiness;//需要测试的business层


    @Autowired
    private DemoResources demoResources;//需要Mock层

    @Test
    public void demoNormal() {
        long helpCustomerId = 111;
        long customerId = 100;
        DemoBusinessPojo demoPojo = new DemoBusinessPojo();
        demoPojo.setContinueDays(5);
        demoPojo.setIncreaseScore(5);
        demoPojo.setLastTime(new Date().getTime());
        demoPojo.setTotalTimes(11);
        //如果传过去的对象或者是参数，而在方法后面又进行重新new了一个新的对象或者参数，那么我们应该传进去的是任何的对象或者参数，
        比如说，customerId传进去，但是真正到达demoBusiness.summit()里面，customerId的值动态变化，那么我们就应该
        //when(demoResources.summit(any(customerId))).thenReturn(demoPojo);//Mock层
        when(demoResources.summit(customerId)).thenReturn(demoPojo);//Mock层

        DemoBusinessPojo demoBusinessPojo = demoBusiness.summit(customerId,
                101, helpCustomerId);//测试层

        assertThat(demoBusinessPojo.getIncreaseScore()).isGreaterThanOrEqualTo(1);
        assertThat(demoBusinessPojo.getContinueDays()).isGreaterThanOrEqualTo(1);
        assertThat(demoBusinessPojo.getLastTime()).isGreaterThan(1);
        assertThat(demoBusinessPojo.getTotalTimes()).isGreaterThanOrEqualTo(1);
    }
}
</code></pre><h4 id="单独测试resource层，跳过直接访问数据库"><a href="#单独测试resource层，跳过直接访问数据库" class="headerlink" title="单独测试resource层，跳过直接访问数据库"></a>单独测试resource层，跳过直接访问数据库</h4><blockquote>
<p>由于到这层是需要直接访问数据库的，所以我们需要直接Mock数据库了，下面上例子：</p>
</blockquote>
<p>有待完善……</p>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><blockquote>
<p>在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p>
</blockquote>
<p>有待完善……</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写测试用例时，如果只关注输入、输出或是否被调用，建议使用Mock框架，能使用Mock的框架有EasyMock、Mockito、PowerMock、JMock等；&lt;/p&gt;
&lt;p&gt;Mock框架在处理”黑洞”接口，有特别的效果，&lt;/p&gt;
&lt;p&gt;下面来分享下Mockito框架的使用：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="mockito" scheme="http://yoursite.com/categories/mockito/"/>
    
    
      <category term="mockito testng" scheme="http://yoursite.com/tags/mockito-testng/"/>
    
  </entry>
  
</feed>
